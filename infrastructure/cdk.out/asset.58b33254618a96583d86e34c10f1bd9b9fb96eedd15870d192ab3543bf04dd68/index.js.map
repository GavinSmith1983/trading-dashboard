{
  "version": 3,
  "sources": ["../../../packages/lambdas/api/src/index.ts", "../../../packages/core/src/types/carrier.ts", "../../../packages/core/src/services/google-sheets.ts", "../../../packages/core/src/services/channel-engine.ts", "../../../packages/core/src/services/pricing-engine.ts", "../../../packages/core/src/services/dynamodb.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';\nimport {\n  createDynamoDBService,\n  createChannelEngineService,\n  Product,\n  PricingRule,\n  Channel,\n  ProposalStatus,\n  BulkApprovalRequest,\n  CarrierCost,\n  normalizeCarrierName,\n  getCarrierDisplayName,\n  isExcludedCarrier,\n} from '@repricing/core';\nimport { v4 as uuid } from 'uuid';\n\nconst db = createDynamoDBService();\n\n/**\n * API Gateway Lambda handler\n * Routes requests to appropriate handlers\n */\nexport async function handler(\n  event: APIGatewayProxyEvent,\n  context: Context\n): Promise<APIGatewayProxyResult> {\n  console.log('API request:', {\n    method: event.httpMethod,\n    path: event.path,\n    requestId: context.awsRequestId,\n  });\n\n  try {\n    const path = event.path;\n    const method = event.httpMethod;\n\n    // Route requests\n    if (path.startsWith('/products')) {\n      return handleProducts(event);\n    }\n    if (path.startsWith('/proposals')) {\n      return handleProposals(event);\n    }\n    if (path.startsWith('/rules')) {\n      return handleRules(event);\n    }\n    if (path.startsWith('/channels')) {\n      return handleChannels(event);\n    }\n    if (path.startsWith('/analytics')) {\n      return handleAnalytics(event);\n    }\n    if (path.startsWith('/import')) {\n      return handleImport(event);\n    }\n    if (path.startsWith('/carriers')) {\n      return handleCarriers(event);\n    }\n    if (path === '/sync' && method === 'POST') {\n      return handleManualSync(event);\n    }\n\n    return response(404, { error: 'Not found' });\n  } catch (error) {\n    console.error('API error:', error);\n    return response(500, {\n      error: error instanceof Error ? error.message : 'Internal server error',\n    });\n  }\n}\n\n// ============ Products ============\n\nasync function handleProducts(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const sku = event.pathParameters?.sku;\n\n  if (method === 'GET' && !sku) {\n    // List all products\n    const products = await db.getAllProducts();\n    return response(200, { items: products, count: products.length });\n  }\n\n  if (method === 'GET' && sku) {\n    // Get single product\n    const product = await db.getProduct(sku);\n    if (!product) {\n      return response(404, { error: 'Product not found' });\n    }\n    return response(200, product);\n  }\n\n  if (method === 'PUT' && sku) {\n    // Update product (costs, delivery)\n    const body = JSON.parse(event.body || '{}');\n    const existing = await db.getProduct(sku);\n\n    if (!existing) {\n      return response(404, { error: 'Product not found' });\n    }\n\n    const updated: Product = {\n      ...existing,\n      costPrice: body.costPrice ?? existing.costPrice,\n      deliveryCost: body.deliveryCost ?? existing.deliveryCost,\n      category: body.category ?? existing.category,\n    };\n\n    await db.putProduct(updated);\n    return response(200, updated);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Proposals ============\n\nasync function handleProposals(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const path = event.path;\n  const proposalId = event.pathParameters?.proposalId;\n\n  // Bulk approve\n  if (path.endsWith('/bulk-approve') && method === 'POST') {\n    const body: BulkApprovalRequest = JSON.parse(event.body || '{}');\n    const results = [];\n\n    for (const id of body.proposalIds) {\n      await db.updateProposalStatus(id, 'approved', body.reviewedBy, body.notes);\n      results.push({ proposalId: id, status: 'approved' });\n    }\n\n    return response(200, { results });\n  }\n\n  // Bulk reject\n  if (path.endsWith('/bulk-reject') && method === 'POST') {\n    const body: BulkApprovalRequest = JSON.parse(event.body || '{}');\n    const results = [];\n\n    for (const id of body.proposalIds) {\n      await db.updateProposalStatus(id, 'rejected', body.reviewedBy, body.notes);\n      results.push({ proposalId: id, status: 'rejected' });\n    }\n\n    return response(200, { results });\n  }\n\n  // Push approved prices to ChannelEngine\n  if (path.endsWith('/push') && method === 'POST') {\n    return handlePushPrices(event);\n  }\n\n  if (method === 'GET' && !proposalId) {\n    // List proposals with filters\n    const params = event.queryStringParameters || {};\n    const filters = {\n      status: params.status as ProposalStatus | undefined,\n      batchId: params.batchId,\n      brand: params.brand,\n      searchTerm: params.search,\n      hasWarnings: params.hasWarnings === 'true',\n    };\n    const page = parseInt(params.page || '1', 10);\n    const pageSize = parseInt(params.pageSize || '50', 10);\n\n    const result = await db.queryProposals(filters, page, pageSize);\n    return response(200, result);\n  }\n\n  if (method === 'GET' && proposalId) {\n    // Get single proposal\n    const proposal = await db.getProposal(proposalId);\n    if (!proposal) {\n      return response(404, { error: 'Proposal not found' });\n    }\n    return response(200, proposal);\n  }\n\n  if (method === 'PUT' && proposalId) {\n    // Update proposal (approve/reject/modify)\n    const body = JSON.parse(event.body || '{}');\n    const { action, modifiedPrice, notes, reviewedBy } = body;\n\n    if (!action || !reviewedBy) {\n      return response(400, { error: 'action and reviewedBy are required' });\n    }\n\n    let status: ProposalStatus;\n    let approvedPrice: number | undefined;\n\n    switch (action) {\n      case 'approve':\n        status = 'approved';\n        break;\n      case 'reject':\n        status = 'rejected';\n        break;\n      case 'modify':\n        if (modifiedPrice === undefined) {\n          return response(400, { error: 'modifiedPrice required for modify action' });\n        }\n        status = 'modified';\n        approvedPrice = modifiedPrice;\n        break;\n      default:\n        return response(400, { error: 'Invalid action' });\n    }\n\n    await db.updateProposalStatus(proposalId, status, reviewedBy, notes, approvedPrice);\n\n    const updated = await db.getProposal(proposalId);\n    return response(200, updated);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\nasync function handlePushPrices(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const body = JSON.parse(event.body || '{}');\n  const dryRun = body.dryRun === true;\n\n  // Get approved proposals\n  const approvedProposals = await db.getProposalsByStatus('approved');\n  const modifiedProposals = await db.getProposalsByStatus('modified');\n  const allApproved = [...approvedProposals, ...modifiedProposals];\n\n  if (allApproved.length === 0) {\n    return response(200, { message: 'No approved proposals to push', count: 0 });\n  }\n\n  // Prepare price updates\n  const updates = allApproved.map((p) => ({\n    merchantProductNo: p.sku,\n    price: p.approvedPrice ?? p.proposedPrice,\n  }));\n\n  if (dryRun) {\n    return response(200, {\n      dryRun: true,\n      count: updates.length,\n      updates,\n    });\n  }\n\n  // Push to ChannelEngine\n  const secretArn = process.env.CHANNEL_ENGINE_SECRET_ARN;\n  if (!secretArn) {\n    return response(500, { error: 'ChannelEngine not configured' });\n  }\n\n  const ceService = await createChannelEngineService(secretArn);\n  const result = await ceService.updatePrices(updates);\n\n  // Update proposal statuses to 'pushed'\n  if (result.success) {\n    for (const proposal of allApproved) {\n      await db.updateProposalStatus(proposal.proposalId, 'pushed', 'system', 'Pushed to ChannelEngine');\n    }\n  }\n\n  return response(200, {\n    success: result.success,\n    pushed: updates.length,\n    errors: result.errors,\n  });\n}\n\n// ============ Rules ============\n\nasync function handleRules(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const ruleId = event.pathParameters?.ruleId;\n\n  if (method === 'GET' && !ruleId) {\n    const rules = await db.getAllRules();\n    return response(200, { items: rules, count: rules.length });\n  }\n\n  if (method === 'GET' && ruleId) {\n    const rule = await db.getRule(ruleId);\n    if (!rule) {\n      return response(404, { error: 'Rule not found' });\n    }\n    return response(200, rule);\n  }\n\n  if (method === 'POST') {\n    const body = JSON.parse(event.body || '{}');\n    const rule: PricingRule = {\n      ruleId: uuid(),\n      name: body.name,\n      description: body.description,\n      priority: body.priority ?? 100,\n      isActive: body.isActive ?? true,\n      conditions: body.conditions || {},\n      action: body.action,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n\n    await db.putRule(rule);\n    return response(201, rule);\n  }\n\n  if (method === 'PUT' && ruleId) {\n    const existing = await db.getRule(ruleId);\n    if (!existing) {\n      return response(404, { error: 'Rule not found' });\n    }\n\n    const body = JSON.parse(event.body || '{}');\n    const updated: PricingRule = {\n      ...existing,\n      name: body.name ?? existing.name,\n      description: body.description ?? existing.description,\n      priority: body.priority ?? existing.priority,\n      isActive: body.isActive ?? existing.isActive,\n      conditions: body.conditions ?? existing.conditions,\n      action: body.action ?? existing.action,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await db.putRule(updated);\n    return response(200, updated);\n  }\n\n  if (method === 'DELETE' && ruleId) {\n    await db.deleteRule(ruleId);\n    return response(204, null);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Channels ============\n\nasync function handleChannels(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const channelId = event.pathParameters?.channelId;\n\n  if (method === 'GET' && !channelId) {\n    const channels = await db.getAllChannels();\n    return response(200, { items: channels, count: channels.length });\n  }\n\n  if (method === 'GET' && channelId) {\n    const channel = await db.getChannel(channelId);\n    if (!channel) {\n      return response(404, { error: 'Channel not found' });\n    }\n    return response(200, channel);\n  }\n\n  if (method === 'PUT' && channelId) {\n    const existing = await db.getChannel(channelId);\n    const body = JSON.parse(event.body || '{}');\n\n    const updated: Channel = {\n      channelId: channelId as any,\n      name: body.name ?? existing?.name ?? channelId,\n      isActive: body.isActive ?? existing?.isActive ?? true,\n      commissionPercent: body.commissionPercent ?? existing?.commissionPercent ?? 0,\n      fixedFee: body.fixedFee ?? existing?.fixedFee,\n      paymentProcessingPercent: body.paymentProcessingPercent ?? existing?.paymentProcessingPercent,\n      defaultAcosPercent: body.defaultAcosPercent ?? existing?.defaultAcosPercent,\n      includeAdvertisingInMargin: body.includeAdvertisingInMargin ?? existing?.includeAdvertisingInMargin ?? true,\n      vatPercent: body.vatPercent ?? existing?.vatPercent ?? 20,\n      pricesIncludeVat: body.pricesIncludeVat ?? existing?.pricesIncludeVat ?? true,\n      channelEngineId: body.channelEngineId ?? existing?.channelEngineId,\n      lastUpdated: new Date().toISOString(),\n    };\n\n    await db.putChannel(updated);\n    return response(200, updated);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Analytics ============\n\nasync function handleAnalytics(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const path = event.path;\n  const params = event.queryStringParameters || {};\n\n  if (path.endsWith('/summary')) {\n    const products = await db.getAllProducts();\n    const pendingProposals = await db.getProposalsByStatus('pending');\n\n    const summary = {\n      totalProducts: products.length,\n      productsWithCosts: products.filter((p) => p.costPrice > 0).length,\n      productsWithoutCosts: products.filter((p) => !p.costPrice || p.costPrice === 0).length,\n      outOfStock: products.filter((p) => p.stockLevel === 0).length,\n      lowStock: products.filter((p) => p.stockLevel > 0 && p.stockLevel < 10).length,\n      pendingProposals: pendingProposals.length,\n      avgMargin:\n        products.length > 0\n          ? products.reduce((sum, p) => sum + (p.calculatedMargin || 0), 0) / products.length\n          : 0,\n    };\n\n    return response(200, summary);\n  }\n\n  if (path.endsWith('/margins')) {\n    const products = await db.getAllProducts();\n\n    // Group by margin bands\n    const marginBands = {\n      negative: products.filter((p) => (p.calculatedMargin || 0) < 0).length,\n      low: products.filter((p) => (p.calculatedMargin || 0) >= 0 && (p.calculatedMargin || 0) < 15).length,\n      target: products.filter((p) => (p.calculatedMargin || 0) >= 15 && (p.calculatedMargin || 0) < 30).length,\n      high: products.filter((p) => (p.calculatedMargin || 0) >= 30).length,\n    };\n\n    return response(200, { marginBands, total: products.length });\n  }\n\n  if (path.endsWith('/sales')) {\n    const days = parseInt(params.days || '7', 10);\n    const salesMap = await db.getSalesBySku(days);\n\n    // Convert Map to object for JSON response\n    const sales: Record<string, { quantity: number; revenue: number }> = {};\n    salesMap.forEach((value, key) => {\n      sales[key] = value;\n    });\n\n    return response(200, { days, skuCount: salesMap.size, sales });\n  }\n\n  return response(404, { error: 'Analytics endpoint not found' });\n}\n\n// ============ Import ============\n\nasync function handleImport(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const path = event.path;\n\n  if (path.endsWith('/costs') && event.httpMethod === 'POST') {\n    // Parse CSV from body\n    const body = JSON.parse(event.body || '{}');\n    const csvData: Array<{ sku: string; costPrice: number; deliveryCost?: number }> = body.data;\n\n    if (!csvData || !Array.isArray(csvData)) {\n      return response(400, { error: 'Invalid data format. Expected { data: [...] }' });\n    }\n\n    // Build lookup maps for case-insensitive SKU matching and Balterley SKU fallback\n    const { bySku, byBalterleySku } = await db.getProductLookupMap();\n    console.log(`[Import] Built lookup maps: ${bySku.size} products by SKU, ${byBalterleySku.size} by Balterley SKU`);\n\n    let updated = 0;\n    let notFound = 0;\n    let matchedByBalterley = 0;\n    const notFoundSkus: string[] = [];\n    const productsToUpdate: Product[] = [];\n\n    for (const row of csvData) {\n      const skuUpper = row.sku.toUpperCase().trim();\n\n      // Try matching by primary SKU first (case-insensitive)\n      let product = bySku.get(skuUpper);\n\n      // If not found, try matching by Balterley SKU\n      if (!product) {\n        product = byBalterleySku.get(skuUpper);\n        if (product) {\n          matchedByBalterley++;\n        }\n      }\n\n      if (product) {\n        product.costPrice = row.costPrice;\n        if (row.deliveryCost !== undefined) {\n          product.deliveryCost = row.deliveryCost;\n        }\n        productsToUpdate.push(product);\n        updated++;\n      } else {\n        notFound++;\n        if (notFoundSkus.length < 20) {\n          notFoundSkus.push(row.sku);\n        }\n      }\n    }\n\n    // Batch write all updates for performance (instead of individual puts)\n    if (productsToUpdate.length > 0) {\n      console.log(`[Import] Batch writing ${productsToUpdate.length} products...`);\n      await db.batchPutProducts(productsToUpdate);\n    }\n\n    // Find database SKUs that weren't in the import file (missing costs)\n    const importedSkuSet = new Set(csvData.map(row => row.sku.toUpperCase().trim()));\n    console.log(`[Import] importedSkuSet size: ${importedSkuSet.size}, bySku size: ${bySku.size}`);\n\n    const dbSkusMissingFromFile: string[] = [];\n    let missingCount = 0;\n    for (const [skuUpper, product] of bySku) {\n      if (!importedSkuSet.has(skuUpper)) {\n        missingCount++;\n        if (dbSkusMissingFromFile.length < 50) {\n          dbSkusMissingFromFile.push(product.sku);\n        }\n      }\n    }\n    const totalDbSkusMissingFromFile = missingCount;\n    console.log(`[Import] Found ${missingCount} DB SKUs missing from file, collected ${dbSkusMissingFromFile.length} samples`);\n\n    console.log(`[Import] Complete: ${updated} updated, ${notFound} not found in DB, ${totalDbSkusMissingFromFile} DB SKUs missing from file, ${matchedByBalterley} matched by Balterley SKU`);\n    if (notFoundSkus.length > 0) {\n      console.log(`[Import] Sample file SKUs not in DB: ${notFoundSkus.join(', ')}`);\n    }\n    if (dbSkusMissingFromFile.length > 0) {\n      console.log(`[Import] Sample DB SKUs missing from file: ${dbSkusMissingFromFile.join(', ')}`);\n    }\n\n    return response(200, {\n      message: 'Cost import complete',\n      updated,\n      notFoundInDb: notFound,\n      matchedByBalterleySku: matchedByBalterley,\n      total: csvData.length,\n      sampleNotFoundInDb: notFoundSkus.length > 0 ? notFoundSkus : undefined,\n      dbProductsMissingFromFile: totalDbSkusMissingFromFile,\n      sampleDbSkusMissingFromFile: dbSkusMissingFromFile.length > 0 ? dbSkusMissingFromFile : undefined,\n    });\n  }\n\n  // Delivery report import (Vector Summary)\n  if (path.endsWith('/delivery') && event.httpMethod === 'POST') {\n    return handleDeliveryImport(event);\n  }\n\n  return response(404, { error: 'Import endpoint not found' });\n}\n\n// ============ Delivery Import ============\n\nasync function handleDeliveryImport(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const body = JSON.parse(event.body || '{}');\n  const deliveryData: Array<{\n    orderNumber: string;\n    parcels: number;\n    carrier: string;\n  }> = body.data;\n\n  if (!deliveryData || !Array.isArray(deliveryData)) {\n    return response(400, { error: 'Invalid data format. Expected { data: [...] }' });\n  }\n\n  console.log(`[DeliveryImport] Processing ${deliveryData.length} delivery records`);\n\n  // Get carrier costs for lookup\n  const carrierCosts = await db.getAllCarrierCosts();\n  const carrierCostMap = new Map(carrierCosts.map(c => [c.carrierId, c.costPerParcel]));\n  console.log(`[DeliveryImport] Loaded ${carrierCosts.length} carrier cost configurations`);\n\n  // Get all orders for matching\n  const allOrders = await db.getAllOrders();\n  console.log(`[DeliveryImport] Loaded ${allOrders.length} orders for matching`);\n\n  // Create lookup maps for orders by various ID formats\n  // PONumber from Vector might match: orderId, channelOrderNo, or part of channelOrderNo\n  const orderByOrderId = new Map(allOrders.map(o => [o.orderId, o]));\n  const orderByChannelOrderNo = new Map(allOrders.map(o => [o.channelOrderNo, o]));\n\n  const carriersFound = new Set<string>();\n  const excludedCarriers = new Set<string>();\n  let ordersProcessed = 0;\n  let ordersMatched = 0;\n  let ordersSkipped = 0; // Excluded carriers\n  let ordersNotFound = 0;\n\n  // Process delivery records\n  for (const record of deliveryData) {\n    ordersProcessed++;\n\n    // Skip excluded carriers (Hold Delivery, Consolidated Delivery, today_despatch)\n    if (isExcludedCarrier(record.carrier)) {\n      excludedCarriers.add(record.carrier);\n      ordersSkipped++;\n      continue;\n    }\n\n    const normalizedCarrier = normalizeCarrierName(record.carrier);\n    if (normalizedCarrier !== 'unknown') {\n      carriersFound.add(normalizedCarrier);\n    }\n\n    // Try to match order by PONumber\n    // PONumber formats: \"65061\", \"12320364167549-REM\", etc.\n    const poNumber = record.orderNumber.trim();\n\n    // Try direct match first\n    let matchedOrder = orderByOrderId.get(poNumber) || orderByChannelOrderNo.get(poNumber);\n\n    // If not found, try stripping suffixes like \"-REM\"\n    if (!matchedOrder && poNumber.includes('-')) {\n      const basePoNumber = poNumber.split('-')[0];\n      matchedOrder = orderByOrderId.get(basePoNumber) || orderByChannelOrderNo.get(basePoNumber);\n    }\n\n    if (matchedOrder) {\n      // Update order with delivery info\n      await db.updateOrderDelivery(matchedOrder.orderId, {\n        deliveryCarrier: normalizedCarrier,\n        deliveryCarrierRaw: record.carrier,\n        deliveryParcels: record.parcels,\n      });\n      ordersMatched++;\n    } else {\n      ordersNotFound++;\n    }\n  }\n\n  // Auto-create carrier cost entries for any new carriers found\n  const newCarriers: CarrierCost[] = [];\n  for (const carrierId of carriersFound) {\n    if (!carrierCostMap.has(carrierId)) {\n      const newCarrier: CarrierCost = {\n        carrierId,\n        carrierName: getCarrierDisplayName(carrierId),\n        costPerParcel: 0, // Default cost - user needs to set\n        isActive: true,\n        lastUpdated: new Date().toISOString(),\n      };\n      newCarriers.push(newCarrier);\n    }\n  }\n\n  if (newCarriers.length > 0) {\n    await db.batchPutCarrierCosts(newCarriers);\n    console.log(`[DeliveryImport] Created ${newCarriers.length} new carrier entries`);\n  }\n\n  console.log(`[DeliveryImport] Complete: ${ordersMatched} matched, ${ordersNotFound} not found, ${ordersSkipped} skipped (excluded carriers)`);\n\n  return response(200, {\n    message: 'Delivery import complete',\n    ordersProcessed,\n    ordersMatched,\n    ordersNotFound,\n    ordersSkipped,\n    excludedCarriers: Array.from(excludedCarriers),\n    carriersFound: Array.from(carriersFound),\n    newCarriersCreated: newCarriers.map(c => c.carrierName),\n    note: ordersMatched > 0\n      ? `Updated ${ordersMatched} orders with delivery info. ${newCarriers.length > 0 ? 'New carriers created - please set costs on the Delivery Costs page.' : ''}`\n      : 'No orders matched. Check that PONumber in Vector Summary matches your ChannelEngine order IDs.',\n  });\n}\n\n// ============ Carriers ============\n\nasync function handleCarriers(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const carrierId = event.pathParameters?.carrierId;\n\n  if (method === 'GET' && !carrierId) {\n    const carriers = await db.getAllCarrierCosts();\n    return response(200, { items: carriers, count: carriers.length });\n  }\n\n  if (method === 'GET' && carrierId) {\n    const carrier = await db.getCarrierCost(carrierId);\n    if (!carrier) {\n      return response(404, { error: 'Carrier not found' });\n    }\n    return response(200, carrier);\n  }\n\n  if (method === 'POST') {\n    const body = JSON.parse(event.body || '{}');\n    const carrierId = normalizeCarrierName(body.carrierName || body.carrierId);\n\n    const carrier: CarrierCost = {\n      carrierId,\n      carrierName: body.carrierName || getCarrierDisplayName(carrierId),\n      costPerParcel: body.costPerParcel ?? 0,\n      isActive: body.isActive ?? true,\n      lastUpdated: new Date().toISOString(),\n    };\n\n    await db.putCarrierCost(carrier);\n    return response(201, carrier);\n  }\n\n  if (method === 'PUT' && carrierId) {\n    const existing = await db.getCarrierCost(carrierId);\n    if (!existing) {\n      return response(404, { error: 'Carrier not found' });\n    }\n\n    const body = JSON.parse(event.body || '{}');\n    const updated: CarrierCost = {\n      ...existing,\n      carrierName: body.carrierName ?? existing.carrierName,\n      costPerParcel: body.costPerParcel ?? existing.costPerParcel,\n      isActive: body.isActive ?? existing.isActive,\n      lastUpdated: new Date().toISOString(),\n    };\n\n    await db.putCarrierCost(updated);\n    return response(200, updated);\n  }\n\n  if (method === 'DELETE' && carrierId) {\n    await db.deleteCarrierCost(carrierId);\n    return response(204, null);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Manual Sync ============\n\nasync function handleManualSync(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  // This would trigger the data-sync lambda\n  // For now, return info about how to trigger it\n  return response(200, {\n    message: 'Manual sync not yet implemented. Use AWS Console to invoke data-sync Lambda.',\n  });\n}\n\n// ============ Helpers ============\n\nfunction response(statusCode: number, body: unknown): APIGatewayProxyResult {\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    },\n    body: body ? JSON.stringify(body) : '',\n  };\n}\n", "/**\n * Carrier cost configuration\n * Used to define delivery costs per carrier\n */\nexport interface CarrierCost {\n  carrierId: string; // Normalized carrier name (e.g., 'homefleet', 'dx', 'dpd')\n  carrierName: string; // Display name (e.g., 'HomeFleet', 'DX', 'DPD Logistics')\n  costPerParcel: number; // Cost per parcel in GBP\n  isActive: boolean;\n  lastUpdated: string;\n}\n\n/**\n * Delivery data from Vector Summary report\n */\nexport interface DeliveryRecord {\n  orderNumber: string; // PONumber from report (ChannelEngine order number)\n  parcels: number; // NoOfPackages\n  carrier: string; // ActualCarrier (normalized)\n  rawCarrier: string; // Original carrier value before normalization\n}\n\n/**\n * Product carrier statistics\n * Used to track which carriers are used most for each product\n */\nexport interface ProductCarrierStats {\n  sku: string;\n  carrierCounts: Record<string, number>; // carrier -> count of deliveries\n  predominantCarrier: string;\n  totalDeliveries: number;\n}\n\n/**\n * Summary of delivery report import\n */\nexport interface DeliveryImportResult {\n  ordersProcessed: number;\n  ordersMatched: number; // Orders matched to our DynamoDB orders\n  ordersNotFound: number;\n  carriersFound: string[]; // Unique carriers discovered\n  productsUpdated: number; // Products with delivery cost updated\n  skuCarrierStats: Record<string, ProductCarrierStats>;\n}\n\n/**\n * Normalize carrier name to a standard format\n * e.g., \"HomeFleet - Route 62\" -> \"homefleet\"\n */\nexport function normalizeCarrierName(rawCarrier: string): string {\n  if (!rawCarrier || rawCarrier.trim() === '') {\n    return 'unknown';\n  }\n\n  const lower = rawCarrier.toLowerCase().trim();\n\n  // HomeFleet variants - strip route numbers\n  if (lower.startsWith('homefleet')) {\n    return 'homefleet';\n  }\n\n  // Standard carriers - just lowercase and trim\n  if (lower.includes('dpd')) return 'dpd';\n  if (lower.includes('dx')) return 'dx';\n  if (lower.includes('arrow')) return 'arrowxl';\n  if (lower.includes('parcelforce')) return 'parcelforce';\n  if (lower.includes('worthington')) return 'ak_worthington';\n  if (lower.includes('consolidated')) return 'consolidated';\n  if (lower.includes('hold delivery')) return 'hold_delivery';\n\n  // Fallback - just normalize the name\n  return lower.replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');\n}\n\n/**\n * Get display name for a normalized carrier ID\n */\nexport function getCarrierDisplayName(carrierId: string): string {\n  const displayNames: Record<string, string> = {\n    homefleet: 'HomeFleet',\n    dpd: 'DPD Logistics',\n    dx: 'DX',\n    arrowxl: 'ArrowXL',\n    parcelforce: 'Parcelforce',\n    ak_worthington: 'AK Worthington',\n    consolidated: 'Consolidated Delivery',\n    hold_delivery: 'Hold Delivery',\n    today_despatch: 'Today Despatch',\n    unknown: 'Unknown',\n  };\n\n  return displayNames[carrierId] || carrierId;\n}\n\n/**\n * Check if a carrier should be excluded from delivery cost calculations\n * Excludes: Hold Delivery, Consolidated Delivery, today_despatch\n */\nexport function isExcludedCarrier(rawCarrier: string): boolean {\n  if (!rawCarrier) return true;\n\n  const lower = rawCarrier.toLowerCase().trim();\n\n  // Excluded carriers\n  if (lower.includes('hold delivery') || lower.includes('hold_delivery')) return true;\n  if (lower.includes('consolidated delivery') || lower.includes('consolidated')) return true;\n  if (lower.includes('today_despatch') || lower.includes('today despatch') || lower === 'today_despatch') return true;\n\n  return false;\n}\n", "import { google, sheets_v4 } from 'googleapis';\nimport { GoogleSheetProduct, Product } from '../types';\n\n/**\n * Google Sheets service for reading pricing data\n */\nexport class GoogleSheetsService {\n  private sheets: sheets_v4.Sheets;\n  private spreadsheetId: string;\n\n  constructor(credentials: object, spreadsheetId: string) {\n    const auth = new google.auth.GoogleAuth({\n      credentials,\n      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],\n    });\n\n    this.sheets = google.sheets({ version: 'v4', auth });\n    this.spreadsheetId = spreadsheetId;\n  }\n\n  /**\n   * Fetch all products from the pricing sheet\n   */\n  async fetchProducts(sheetName: string = 'Sheet1'): Promise<GoogleSheetProduct[]> {\n    const response = await this.sheets.spreadsheets.values.get({\n      spreadsheetId: this.spreadsheetId,\n      range: `${sheetName}!A:O`, // Columns A through O based on sheet structure\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    // First row is headers\n    const headers = rows[0];\n    const dataRows = rows.slice(1);\n\n    return dataRows\n      .filter((row) => row[1]) // Must have SKU\n      .map((row) => this.parseRow(row, headers));\n  }\n\n  /**\n   * Parse a single row into a GoogleSheetProduct\n   */\n  private parseRow(row: string[], headers: string[]): GoogleSheetProduct {\n    const getValue = (index: number): string => row[index]?.trim() || '';\n    const getNumber = (index: number): number => {\n      const val = row[index]?.replace(/[\u00A3$,]/g, '').trim();\n      return parseFloat(val) || 0;\n    };\n\n    // Map columns based on known sheet structure\n    // Columns: Brand Name, Product SKU, Balterley SKU, Family Variants, MRP,\n    //          B&Q Pricing, Amazon Pricing, eBay Pricing, ManoMano Pricing, Shopify Pricing,\n    //          (empty), discount-start-date, discount-end-date, discount-price\n    return {\n      brandName: getValue(0),\n      productSku: getValue(1),\n      balterleySku: getValue(2),\n      familyVariants: getValue(3),\n      mrp: getNumber(4),\n      bandqPricing: getNumber(5),\n      amazonPricing: getNumber(6),\n      ebayPricing: getNumber(7),\n      manoManoPricing: getNumber(8),\n      shopifyPricing: getNumber(9),\n      discountStartDate: getValue(11) || undefined,\n      discountEndDate: getValue(12) || undefined,\n      discountPrice: getNumber(13) || undefined,\n    };\n  }\n\n  /**\n   * Transform Google Sheet product to internal Product format\n   * Note: Cost and delivery data must be merged from separate sources\n   */\n  static toProduct(sheetProduct: GoogleSheetProduct): Partial<Product> {\n    // For unified pricing, use Amazon price as the base (most common)\n    // or calculate average of non-zero prices\n    const prices = [\n      sheetProduct.amazonPricing,\n      sheetProduct.ebayPricing,\n      sheetProduct.bandqPricing,\n      sheetProduct.manoManoPricing,\n      sheetProduct.shopifyPricing,\n    ].filter((p) => p > 0);\n\n    const currentPrice = prices.length > 0 ? prices[0] : sheetProduct.mrp;\n\n    return {\n      sku: sheetProduct.productSku,\n      balterleySku: sheetProduct.balterleySku || undefined,\n      title: sheetProduct.productSku, // Will be enriched from ChannelEngine\n      brand: sheetProduct.brandName,\n      familyVariants: sheetProduct.familyVariants || undefined,\n      mrp: sheetProduct.mrp,\n      currentPrice,\n      channelPrices: {\n        amazon: sheetProduct.amazonPricing || undefined,\n        ebay: sheetProduct.ebayPricing || undefined,\n        bandq: sheetProduct.bandqPricing || undefined,\n        manomano: sheetProduct.manoManoPricing || undefined,\n        shopify: sheetProduct.shopifyPricing || undefined,\n      },\n      discountPrice: sheetProduct.discountPrice || undefined,\n      discountStartDate: sheetProduct.discountStartDate || undefined,\n      discountEndDate: sheetProduct.discountEndDate || undefined,\n      lastSyncedFromSheet: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Get sheet metadata to find available sheets\n   */\n  async getSheetNames(): Promise<string[]> {\n    const response = await this.sheets.spreadsheets.get({\n      spreadsheetId: this.spreadsheetId,\n    });\n\n    return response.data.sheets?.map((s) => s.properties?.title || '') || [];\n  }\n}\n\n/**\n * Factory function to create GoogleSheetsService from AWS Secrets\n */\nexport async function createGoogleSheetsService(\n  secretArn: string\n): Promise<GoogleSheetsService> {\n  // Import dynamically to avoid bundling issues\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('Google Sheets secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n  const credentials = JSON.parse(secret.credentials);\n\n  return new GoogleSheetsService(credentials, secret.spreadsheetId);\n}\n", "import { ChannelEngineProduct, ChannelEngineSalesData, ChannelEngineOrder, ChannelEngineOrderLine } from '../types';\n\n/**\n * ChannelEngine API configuration\n */\ninterface ChannelEngineConfig {\n  apiKey: string;\n  tenantId: string;\n  baseUrl?: string;\n}\n\n/**\n * ChannelEngine API response wrapper\n */\ninterface ChannelEngineResponse<T> {\n  Content: T;\n  StatusCode: number;\n  Success: boolean;\n  Message?: string;\n  TotalCount?: number;\n}\n\n/**\n * ChannelEngine product from API\n */\ninterface CEProduct {\n  MerchantProductNo: string;\n  Name: string;\n  Description?: string;\n  Brand?: string;\n  Stock: number;\n  Price: number;\n  CategoryTrail?: string;\n  Ean?: string;\n}\n\n/**\n * ChannelEngine order line item\n */\ninterface CEOrderLine {\n  MerchantProductNo: string;\n  Quantity: number;\n  UnitPriceInclVat: number;\n  OrderDateUtc: string;\n}\n\n/**\n * ChannelEngine service for inventory and sales data\n */\nexport class ChannelEngineService {\n  private apiKey: string;\n  private tenantId: string;\n  private baseUrl: string;\n\n  constructor(config: ChannelEngineConfig) {\n    this.apiKey = config.apiKey;\n    this.tenantId = config.tenantId;\n    this.baseUrl = config.baseUrl || 'https://api.channelengine.net/api/v2';\n  }\n\n  /**\n   * Make authenticated request to ChannelEngine API\n   * Authentication is via apikey query parameter (not header)\n   */\n  private async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST' | 'PUT' = 'GET',\n    body?: unknown,\n    queryParams: Record<string, string | number> = {}\n  ): Promise<ChannelEngineResponse<T>> {\n    // Add API key to query parameters (ChannelEngine's authentication method)\n    const params = new URLSearchParams();\n    params.set('apikey', this.apiKey);\n    for (const [key, value] of Object.entries(queryParams)) {\n      params.set(key, String(value));\n    }\n\n    const url = `${this.baseUrl}${endpoint}?${params.toString()}`;\n\n    const response = await fetch(url, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`ChannelEngine API error: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json() as Promise<ChannelEngineResponse<T>>;\n  }\n\n  /**\n   * Fetch all products with full details (stock, price, name, brand, etc.)\n   * Calls onBatch callback after each page to allow incremental processing/saving\n   */\n  async fetchProducts(onBatch?: (products: ChannelEngineProduct[], page: number, total: number) => Promise<void>): Promise<ChannelEngineProduct[]> {\n    const allProducts: ChannelEngineProduct[] = [];\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n    let totalCount = 0;\n\n    console.log(`[CE] Starting product fetch from ${this.baseUrl}/products`);\n\n    while (hasMore) {\n      console.log(`[CE] Fetching page ${page}...`);\n\n      try {\n        const response = await this.request<CEProduct[]>(\n          '/products',\n          'GET',\n          undefined,\n          { page, pageSize }\n        );\n\n        totalCount = response.TotalCount || totalCount;\n\n        if (response.Content && response.Content.length > 0) {\n          const batchProducts: ChannelEngineProduct[] = [];\n\n          for (const product of response.Content) {\n            batchProducts.push({\n              merchantProductNo: product.MerchantProductNo,\n              name: product.Name,\n              description: product.Description,\n              brand: product.Brand,\n              ean: product.Ean,\n              stock: product.Stock,\n              price: product.Price,\n              categoryTrail: product.CategoryTrail,\n            });\n          }\n\n          allProducts.push(...batchProducts);\n          console.log(`[CE] Page ${page}: Got ${batchProducts.length} products (${allProducts.length}/${totalCount})`);\n\n          // Call batch callback to save immediately\n          if (onBatch) {\n            await onBatch(batchProducts, page, totalCount);\n          }\n\n          page++;\n          hasMore = response.Content.length === pageSize;\n        } else {\n          console.log(`[CE] Page ${page}: No more products`);\n          hasMore = false;\n        }\n      } catch (error) {\n        console.error(`[CE] Error fetching page ${page}:`, error);\n        throw error;\n      }\n    }\n\n    console.log(`[CE] Completed: Fetched ${allProducts.length} total products`);\n    return allProducts;\n  }\n\n  /**\n   * Fetch sales data for products over a date range\n   */\n  async fetchSalesData(\n    fromDate: Date,\n    toDate: Date\n  ): Promise<Map<string, { quantity: number; revenue: number }>> {\n    const salesMap = new Map<string, { quantity: number; revenue: number }>();\n\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n\n    const fromStr = fromDate.toISOString();\n    const toStr = toDate.toISOString();\n\n    while (hasMore) {\n      const response = await this.request<{ Lines: CEOrderLine[] }[]>(\n        '/orders',\n        'GET',\n        undefined,\n        { fromDate: fromStr, toDate: toStr, page, pageSize }\n      );\n\n      if (response.Content && response.Content.length > 0) {\n        for (const order of response.Content) {\n          if (order.Lines) {\n            for (const line of order.Lines) {\n              const existing = salesMap.get(line.MerchantProductNo) || {\n                quantity: 0,\n                revenue: 0,\n              };\n              existing.quantity += line.Quantity;\n              existing.revenue += line.UnitPriceInclVat * line.Quantity;\n              salesMap.set(line.MerchantProductNo, existing);\n            }\n          }\n        }\n        page++;\n        hasMore = response.Content.length === pageSize;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return salesMap;\n  }\n\n  /**\n   * Calculate sales metrics for last 7 and 30 days\n   */\n  async fetchSalesMetrics(): Promise<ChannelEngineSalesData[]> {\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    const [sales7Days, sales30Days] = await Promise.all([\n      this.fetchSalesData(sevenDaysAgo, now),\n      this.fetchSalesData(thirtyDaysAgo, now),\n    ]);\n\n    // Combine all SKUs from both periods\n    const allSkus = new Set([...sales7Days.keys(), ...sales30Days.keys()]);\n\n    return Array.from(allSkus).map((sku) => ({\n      merchantProductNo: sku,\n      salesLast7Days: sales7Days.get(sku)?.quantity || 0,\n      salesLast30Days: sales30Days.get(sku)?.quantity || 0,\n    }));\n  }\n\n  /**\n   * Fetch all orders from a given date with incremental batch processing\n   * @param fromDate Start date to fetch orders from\n   * @param onBatch Callback called after each page for incremental saving\n   */\n  async fetchOrders(\n    fromDate: Date,\n    onBatch?: (orders: ChannelEngineOrder[], page: number, total: number) => Promise<void>\n  ): Promise<ChannelEngineOrder[]> {\n    const allOrders: ChannelEngineOrder[] = [];\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n    let totalCount = 0;\n\n    const fromStr = fromDate.toISOString();\n    console.log(`[CE] Starting order fetch from ${fromStr}`);\n\n    while (hasMore) {\n      console.log(`[CE] Fetching orders page ${page}...`);\n\n      try {\n        const response = await this.request<ChannelEngineOrder[]>(\n          '/orders',\n          'GET',\n          undefined,\n          { fromDate: fromStr, page, pageSize }\n        );\n\n        totalCount = response.TotalCount || totalCount;\n\n        if (response.Content && response.Content.length > 0) {\n          allOrders.push(...response.Content);\n          console.log(`[CE] Page ${page}: Got ${response.Content.length} orders (${allOrders.length}/${totalCount})`);\n\n          // Call batch callback to save immediately\n          if (onBatch) {\n            await onBatch(response.Content, page, totalCount);\n          }\n\n          page++;\n          hasMore = response.Content.length === pageSize;\n        } else {\n          console.log(`[CE] Page ${page}: No more orders`);\n          hasMore = false;\n        }\n      } catch (error) {\n        console.error(`[CE] Error fetching orders page ${page}:`, error);\n        throw error;\n      }\n    }\n\n    console.log(`[CE] Completed: Fetched ${allOrders.length} total orders`);\n    return allOrders;\n  }\n\n  /**\n   * Update product prices in ChannelEngine\n   */\n  async updatePrices(\n    updates: Array<{ merchantProductNo: string; price: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n\n    // ChannelEngine API typically accepts batch updates\n    // Update in chunks of 100\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Price: u.price,\n        }));\n\n        const response = await this.request<unknown>(\n          '/products/bulk',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Update stock levels in ChannelEngine\n   */\n  async updateStock(\n    updates: Array<{ merchantProductNo: string; stock: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Stock: u.stock,\n        }));\n\n        const response = await this.request<unknown>(\n          '/offer/stock',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n/**\n * Factory function to create ChannelEngineService from AWS Secrets\n */\nexport async function createChannelEngineService(\n  secretArn: string\n): Promise<ChannelEngineService> {\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('ChannelEngine secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n\n  return new ChannelEngineService({\n    apiKey: secret.apiKey,\n    tenantId: secret.tenantId,\n    baseUrl: secret.baseUrl,\n  });\n}\n", "import {\n  Product,\n  Channel,\n  PricingRule,\n  PricingConfig,\n  PriceCalculationResult,\n  CostBreakdown,\n  calculateCostBreakdown,\n  DEFAULT_PRICING_CONFIG,\n  RoundingRule,\n  PriceProposal,\n} from '../types';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Pricing engine - applies rules to calculate optimal prices\n */\nexport class PricingEngine {\n  private config: PricingConfig;\n  private rules: PricingRule[];\n  private channels: Map<string, Channel>;\n\n  constructor(\n    config: PricingConfig = DEFAULT_PRICING_CONFIG,\n    rules: PricingRule[] = [],\n    channels: Channel[] = []\n  ) {\n    this.config = config;\n    this.rules = rules.sort((a, b) => a.priority - b.priority);\n    this.channels = new Map(channels.map((c) => [c.channelId, c]));\n  }\n\n  /**\n   * Calculate proposed price for a product\n   */\n  calculatePrice(product: Product, channelId: string = 'amazon'): PriceCalculationResult {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not configured`);\n    }\n\n    const warnings: string[] = [];\n\n    // Check if product has required cost data\n    if (!product.costPrice || product.costPrice <= 0) {\n      warnings.push('Missing cost price - cannot calculate accurate margin');\n    }\n\n    // Calculate current margin\n    const currentBreakdown = this.calculateCostBreakdown(product, product.currentPrice, channel);\n\n    // Find applicable rule\n    const applicableRule = this.findApplicableRule(product, currentBreakdown);\n\n    // Calculate proposed price\n    let proposedPrice = product.currentPrice;\n    let reason = 'No rule applied - price unchanged';\n\n    if (applicableRule) {\n      const result = this.applyRule(applicableRule, product, channel);\n      proposedPrice = result.price;\n      reason = result.reason;\n    }\n\n    // Apply rounding\n    proposedPrice = this.applyRounding(proposedPrice, this.config.defaultRoundingRule);\n\n    // Enforce floor price (minimum margin)\n    const floorPrice = this.calculateFloorPrice(product, channel);\n    let atFloorPrice = false;\n    if (proposedPrice < floorPrice) {\n      proposedPrice = this.applyRounding(floorPrice, this.config.defaultRoundingRule);\n      warnings.push(`Price raised to floor (${this.config.minimumMarginPercent}% minimum margin)`);\n      atFloorPrice = true;\n    }\n\n    // Enforce ceiling price (MRP or max discount)\n    const ceilingPrice = product.mrp;\n    let atCeilingPrice = false;\n    if (proposedPrice > ceilingPrice) {\n      proposedPrice = ceilingPrice;\n      warnings.push('Price capped at MRP');\n      atCeilingPrice = true;\n    }\n\n    // Calculate final breakdown\n    const proposedBreakdown = this.calculateCostBreakdown(product, proposedPrice, channel);\n\n    // Check if below minimum margin\n    const belowMinimumMargin = proposedBreakdown.marginPercent < this.config.minimumMarginPercent;\n    if (belowMinimumMargin && !atFloorPrice) {\n      warnings.push(\n        `Margin (${proposedBreakdown.marginPercent.toFixed(1)}%) below minimum (${this.config.minimumMarginPercent}%)`\n      );\n    }\n\n    return {\n      sku: product.sku,\n      currentPrice: product.currentPrice,\n      proposedPrice,\n      priceChange: proposedPrice - product.currentPrice,\n      priceChangePercent:\n        product.currentPrice > 0\n          ? ((proposedPrice - product.currentPrice) / product.currentPrice) * 100\n          : 0,\n      currentMargin: currentBreakdown.marginPercent,\n      proposedMargin: proposedBreakdown.marginPercent,\n      marginChange: proposedBreakdown.marginPercent - currentBreakdown.marginPercent,\n      currentProfit: currentBreakdown.netProfit,\n      proposedProfit: proposedBreakdown.netProfit,\n      costBreakdown: proposedBreakdown,\n      appliedRule: applicableRule?.name,\n      reason,\n      warnings,\n      belowMinimumMargin,\n      atFloorPrice,\n      atCeilingPrice,\n    };\n  }\n\n  /**\n   * Calculate cost breakdown for a price\n   */\n  private calculateCostBreakdown(\n    product: Product,\n    price: number,\n    channel: Channel\n  ): CostBreakdown {\n    const advertisingPercent = channel.includeAdvertisingInMargin\n      ? channel.defaultAcosPercent || 0\n      : 0;\n\n    return calculateCostBreakdown(\n      price,\n      product.costPrice || 0,\n      product.deliveryCost || 0,\n      channel.commissionPercent,\n      channel.fixedFee || 0,\n      channel.paymentProcessingPercent || 0,\n      advertisingPercent,\n      channel.vatPercent,\n      channel.pricesIncludeVat\n    );\n  }\n\n  /**\n   * Find the first rule that applies to this product\n   */\n  private findApplicableRule(\n    product: Product,\n    currentBreakdown: CostBreakdown\n  ): PricingRule | undefined {\n    for (const rule of this.rules) {\n      if (!rule.isActive) continue;\n      if (this.ruleMatches(rule, product, currentBreakdown)) {\n        return rule;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if a rule's conditions match the product\n   */\n  private ruleMatches(\n    rule: PricingRule,\n    product: Product,\n    breakdown: CostBreakdown\n  ): boolean {\n    const conditions = rule.conditions;\n\n    // Brand filter\n    if (conditions.brands && conditions.brands.length > 0) {\n      if (!conditions.brands.includes(product.brand)) return false;\n    }\n\n    // Category filter\n    if (conditions.categories && conditions.categories.length > 0) {\n      if (!product.category || !conditions.categories.includes(product.category)) return false;\n    }\n\n    // SKU filter\n    if (conditions.skus && conditions.skus.length > 0) {\n      if (!conditions.skus.includes(product.sku)) return false;\n    }\n\n    // SKU pattern filter\n    if (conditions.skuPatterns && conditions.skuPatterns.length > 0) {\n      const matches = conditions.skuPatterns.some((pattern) =>\n        new RegExp(pattern).test(product.sku)\n      );\n      if (!matches) return false;\n    }\n\n    // Margin conditions\n    if (conditions.marginBelow !== undefined) {\n      if (breakdown.marginPercent >= conditions.marginBelow) return false;\n    }\n    if (conditions.marginAbove !== undefined) {\n      if (breakdown.marginPercent <= conditions.marginAbove) return false;\n    }\n\n    // Stock conditions\n    if (conditions.stockBelow !== undefined) {\n      if (product.stockLevel >= conditions.stockBelow) return false;\n    }\n    if (conditions.stockAbove !== undefined) {\n      if (product.stockLevel <= conditions.stockAbove) return false;\n    }\n\n    // Sales velocity conditions\n    if (conditions.salesVelocityBelow !== undefined) {\n      if (product.salesLast7Days >= conditions.salesVelocityBelow) return false;\n    }\n    if (conditions.salesVelocityAbove !== undefined) {\n      if (product.salesLast7Days <= conditions.salesVelocityAbove) return false;\n    }\n\n    // Price conditions\n    if (conditions.priceBelow !== undefined) {\n      if (product.currentPrice >= conditions.priceBelow) return false;\n    }\n    if (conditions.priceAbove !== undefined) {\n      if (product.currentPrice <= conditions.priceAbove) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Apply a rule's action to calculate new price\n   */\n  private applyRule(\n    rule: PricingRule,\n    product: Product,\n    channel: Channel\n  ): { price: number; reason: string } {\n    const action = rule.action;\n\n    switch (action.type) {\n      case 'set_margin': {\n        // Calculate price to achieve target margin\n        const targetMargin = action.value / 100;\n        const totalCostRate =\n          (channel.commissionPercent +\n            (channel.paymentProcessingPercent || 0) +\n            (channel.defaultAcosPercent || 0)) /\n          100;\n        const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n        // Price = FixedCosts / (1 - totalCostRate - targetMargin)\n        const divisor = 1 - totalCostRate - targetMargin;\n        if (divisor <= 0) {\n          return {\n            price: product.currentPrice,\n            reason: `Cannot achieve ${action.value}% margin - costs too high`,\n          };\n        }\n        const price = fixedCosts / divisor;\n        return {\n          price,\n          reason: `Set to achieve ${action.value}% margin (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_markup': {\n        // Price = Cost \u00D7 Markup multiplier\n        const price = (product.costPrice || 0) * action.value;\n        return {\n          price,\n          reason: `Applied ${action.value}x markup on cost (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_percent': {\n        // Adjust by percentage\n        const price = product.currentPrice * (1 + action.value / 100);\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `${Math.abs(action.value)}% ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_fixed': {\n        // Adjust by fixed amount\n        const price = product.currentPrice + action.value;\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `\u00A3${Math.abs(action.value).toFixed(2)} ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_price': {\n        return {\n          price: action.value,\n          reason: `Set to fixed price \u00A3${action.value.toFixed(2)} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'match_mrp': {\n        return {\n          price: product.mrp,\n          reason: `Set to MRP (rule: ${rule.name})`,\n        };\n      }\n\n      case 'discount_from_mrp': {\n        const price = product.mrp * (1 - action.value / 100);\n        return {\n          price,\n          reason: `${action.value}% discount from MRP (rule: ${rule.name})`,\n        };\n      }\n\n      default:\n        return {\n          price: product.currentPrice,\n          reason: 'Unknown action type',\n        };\n    }\n  }\n\n  /**\n   * Calculate floor price (minimum to achieve minimum margin)\n   */\n  private calculateFloorPrice(product: Product, channel: Channel): number {\n    const targetMargin = this.config.minimumMarginPercent / 100;\n    const totalCostRate =\n      (channel.commissionPercent +\n        (channel.paymentProcessingPercent || 0) +\n        (channel.defaultAcosPercent || 0)) /\n      100;\n    const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n    const divisor = 1 - totalCostRate - targetMargin;\n    if (divisor <= 0) return product.currentPrice;\n\n    return fixedCosts / divisor;\n  }\n\n  /**\n   * Apply rounding rule to price\n   */\n  private applyRounding(price: number, rule: RoundingRule): number {\n    switch (rule) {\n      case 'nearest_99p':\n        return Math.floor(price) + 0.99;\n      case 'nearest_95p':\n        return Math.floor(price) + 0.95;\n      case 'nearest_pound':\n        return Math.round(price);\n      case 'round_down':\n        return Math.floor(price * 100) / 100;\n      case 'round_up':\n        return Math.ceil(price * 100) / 100;\n      case 'none':\n      default:\n        return Math.round(price * 100) / 100;\n    }\n  }\n\n  /**\n   * Generate proposals for all products\n   */\n  generateProposals(products: Product[], batchId: string): PriceProposal[] {\n    const proposals: PriceProposal[] = [];\n\n    for (const product of products) {\n      const result = this.calculatePrice(product);\n\n      // Only create proposal if price changed\n      if (Math.abs(result.priceChange) < 0.01) continue;\n\n      const proposal: PriceProposal = {\n        proposalId: uuid(),\n        sku: product.sku,\n        productTitle: product.title,\n        brand: product.brand,\n        category: product.category,\n        currentPrice: result.currentPrice,\n        proposedPrice: result.proposedPrice,\n        priceChange: result.priceChange,\n        priceChangePercent: result.priceChangePercent,\n        currentMargin: result.currentMargin,\n        proposedMargin: result.proposedMargin,\n        marginChange: result.marginChange,\n        costBreakdown: result.costBreakdown,\n        stockLevel: product.stockLevel,\n        salesLast7Days: product.salesLast7Days,\n        salesLast30Days: product.salesLast30Days,\n        appliedRuleName: result.appliedRule,\n        reason: result.reason,\n        warnings: result.warnings,\n        status: 'pending',\n        createdAt: new Date().toISOString(),\n        batchId,\n        ttl: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60, // 30 days\n      };\n\n      proposals.push(proposal);\n    }\n\n    return proposals;\n  }\n}\n", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport {\n  DynamoDBDocumentClient,\n  GetCommand,\n  PutCommand,\n  QueryCommand,\n  ScanCommand,\n  UpdateCommand,\n  BatchWriteCommand,\n} from '@aws-sdk/lib-dynamodb';\nimport {\n  Product,\n  Channel,\n  PricingRule,\n  PriceProposal,\n  ProposalStatus,\n  ProposalFilters,\n  PaginatedProposals,\n  Order,\n  CarrierCost,\n} from '../types';\n\n/**\n * DynamoDB service for all database operations\n */\nexport class DynamoDBService {\n  private docClient: DynamoDBDocumentClient;\n  private productsTable: string;\n  private rulesTable: string;\n  private proposalsTable: string;\n  private channelsTable: string;\n  private ordersTable: string;\n  private carrierCostsTable: string;\n\n  constructor(config: {\n    productsTable: string;\n    rulesTable: string;\n    proposalsTable: string;\n    channelsTable: string;\n    ordersTable?: string;\n    carrierCostsTable?: string;\n  }) {\n    const client = new DynamoDBClient({});\n    this.docClient = DynamoDBDocumentClient.from(client, {\n      marshallOptions: { removeUndefinedValues: true },\n    });\n\n    this.productsTable = config.productsTable;\n    this.rulesTable = config.rulesTable;\n    this.proposalsTable = config.proposalsTable;\n    this.channelsTable = config.channelsTable;\n    this.ordersTable = config.ordersTable || 'repricing-orders';\n    this.carrierCostsTable = config.carrierCostsTable || 'repricing-carrier-costs';\n  }\n\n  // ============ Products ============\n\n  async getProduct(sku: string): Promise<Product | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.productsTable,\n        Key: { sku },\n      })\n    );\n    return (result.Item as Product) || null;\n  }\n\n  async putProduct(product: Product): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.productsTable,\n        Item: { ...product, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllProducts(): Promise<Product[]> {\n    const products: Product[] = [];\n    let lastKey: Record<string, unknown> | undefined;\n\n    do {\n      const result = await this.docClient.send(\n        new ScanCommand({\n          TableName: this.productsTable,\n          ExclusiveStartKey: lastKey,\n        })\n      );\n\n      if (result.Items) {\n        products.push(...(result.Items as Product[]));\n      }\n      lastKey = result.LastEvaluatedKey;\n    } while (lastKey);\n\n    return products;\n  }\n\n  async batchPutProducts(products: Product[]): Promise<void> {\n    const timestamp = new Date().toISOString();\n\n    // DynamoDB batch write limit is 25 items\n    const chunks = this.chunkArray(products, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.productsTable]: chunk.map((product) => ({\n              PutRequest: {\n                Item: { ...product, lastUpdated: timestamp },\n              },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProductsByBrand(brand: string): Promise<Product[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.productsTable,\n        IndexName: 'by-brand',\n        KeyConditionExpression: 'brand = :brand',\n        ExpressionAttributeValues: { ':brand': brand },\n      })\n    );\n    return (result.Items as Product[]) || [];\n  }\n\n  // ============ Pricing Rules ============\n\n  async getRule(ruleId: string): Promise<PricingRule | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n    return (result.Item as PricingRule) || null;\n  }\n\n  async putRule(rule: PricingRule): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.rulesTable,\n        Item: { ...rule, updatedAt: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllRules(): Promise<PricingRule[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.rulesTable,\n      })\n    );\n    return ((result.Items as PricingRule[]) || []).sort((a, b) => a.priority - b.priority);\n  }\n\n  async deleteRule(ruleId: string): Promise<void> {\n    const { DeleteCommand } = await import('@aws-sdk/lib-dynamodb');\n    await this.docClient.send(\n      new DeleteCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n  }\n\n  // ============ Proposals ============\n\n  async getProposal(proposalId: string): Promise<PriceProposal | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n      })\n    );\n    return (result.Item as PriceProposal) || null;\n  }\n\n  async putProposal(proposal: PriceProposal): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.proposalsTable,\n        Item: proposal,\n      })\n    );\n  }\n\n  async batchPutProposals(proposals: PriceProposal[]): Promise<void> {\n    const chunks = this.chunkArray(proposals, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.proposalsTable]: chunk.map((proposal) => ({\n              PutRequest: { Item: proposal },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProposalsByStatus(status: ProposalStatus): Promise<PriceProposal[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.proposalsTable,\n        IndexName: 'by-status',\n        KeyConditionExpression: '#status = :status',\n        ExpressionAttributeNames: { '#status': 'status' },\n        ExpressionAttributeValues: { ':status': status },\n        ScanIndexForward: false, // Most recent first\n      })\n    );\n    return (result.Items as PriceProposal[]) || [];\n  }\n\n  async queryProposals(\n    filters: ProposalFilters,\n    page: number = 1,\n    pageSize: number = 50\n  ): Promise<PaginatedProposals> {\n    // Build filter expression\n    const filterExpressions: string[] = [];\n    const expressionAttributeNames: Record<string, string> = {};\n    const expressionAttributeValues: Record<string, unknown> = {};\n\n    if (filters.status) {\n      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];\n      if (statuses.length === 1) {\n        filterExpressions.push('#status = :status');\n        expressionAttributeNames['#status'] = 'status';\n        expressionAttributeValues[':status'] = statuses[0];\n      }\n    }\n\n    if (filters.brand) {\n      filterExpressions.push('brand = :brand');\n      expressionAttributeValues[':brand'] = filters.brand;\n    }\n\n    if (filters.batchId) {\n      filterExpressions.push('batchId = :batchId');\n      expressionAttributeValues[':batchId'] = filters.batchId;\n    }\n\n    if (filters.hasWarnings) {\n      filterExpressions.push('size(warnings) > :zero');\n      expressionAttributeValues[':zero'] = 0;\n    }\n\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.proposalsTable,\n        FilterExpression: filterExpressions.length > 0 ? filterExpressions.join(' AND ') : undefined,\n        ExpressionAttributeNames:\n          Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,\n        ExpressionAttributeValues:\n          Object.keys(expressionAttributeValues).length > 0 ? expressionAttributeValues : undefined,\n      })\n    );\n\n    let items = (result.Items as PriceProposal[]) || [];\n\n    // Apply search filter (client-side for simplicity)\n    if (filters.searchTerm) {\n      const term = filters.searchTerm.toLowerCase();\n      items = items.filter(\n        (p) =>\n          p.sku.toLowerCase().includes(term) ||\n          p.productTitle.toLowerCase().includes(term)\n      );\n    }\n\n    // Sort by createdAt descending\n    items.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Paginate\n    const totalCount = items.length;\n    const startIndex = (page - 1) * pageSize;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n\n    return {\n      items: paginatedItems,\n      totalCount,\n      page,\n      pageSize,\n      hasMore: startIndex + pageSize < totalCount,\n    };\n  }\n\n  async updateProposalStatus(\n    proposalId: string,\n    status: ProposalStatus,\n    reviewedBy: string,\n    notes?: string,\n    approvedPrice?: number\n  ): Promise<void> {\n    const updateExpressions: string[] = [\n      '#status = :status',\n      'reviewedAt = :reviewedAt',\n      'reviewedBy = :reviewedBy',\n    ];\n    const expressionAttributeNames: Record<string, string> = { '#status': 'status' };\n    const expressionAttributeValues: Record<string, unknown> = {\n      ':status': status,\n      ':reviewedAt': new Date().toISOString(),\n      ':reviewedBy': reviewedBy,\n    };\n\n    if (notes) {\n      updateExpressions.push('reviewNotes = :notes');\n      expressionAttributeValues[':notes'] = notes;\n    }\n\n    if (approvedPrice !== undefined) {\n      updateExpressions.push('approvedPrice = :approvedPrice');\n      expressionAttributeValues[':approvedPrice'] = approvedPrice;\n    }\n\n    await this.docClient.send(\n      new UpdateCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n        UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n        ExpressionAttributeNames: expressionAttributeNames,\n        ExpressionAttributeValues: expressionAttributeValues,\n      })\n    );\n  }\n\n  // ============ Channels ============\n\n  async getChannel(channelId: string): Promise<Channel | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.channelsTable,\n        Key: { channelId },\n      })\n    );\n    return (result.Item as Channel) || null;\n  }\n\n  async putChannel(channel: Channel): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.channelsTable,\n        Item: { ...channel, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllChannels(): Promise<Channel[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.channelsTable,\n      })\n    );\n    return (result.Items as Channel[]) || [];\n  }\n\n  // ============ Carrier Costs ============\n\n  async getCarrierCost(carrierId: string): Promise<CarrierCost | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.carrierCostsTable,\n        Key: { carrierId },\n      })\n    );\n    return (result.Item as CarrierCost) || null;\n  }\n\n  async putCarrierCost(carrier: CarrierCost): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.carrierCostsTable,\n        Item: { ...carrier, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllCarrierCosts(): Promise<CarrierCost[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.carrierCostsTable,\n      })\n    );\n    return (result.Items as CarrierCost[]) || [];\n  }\n\n  async deleteCarrierCost(carrierId: string): Promise<void> {\n    const { DeleteCommand } = await import('@aws-sdk/lib-dynamodb');\n    await this.docClient.send(\n      new DeleteCommand({\n        TableName: this.carrierCostsTable,\n        Key: { carrierId },\n      })\n    );\n  }\n\n  async batchPutCarrierCosts(carriers: CarrierCost[]): Promise<void> {\n    const timestamp = new Date().toISOString();\n    const chunks = this.chunkArray(carriers, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.carrierCostsTable]: chunk.map((carrier) => ({\n              PutRequest: {\n                Item: { ...carrier, lastUpdated: timestamp },\n              },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  // ============ Orders ============\n\n  async batchPutOrders(orders: Order[]): Promise<void> {\n    const chunks = this.chunkArray(orders, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.ordersTable]: chunk.map((order) => ({\n              PutRequest: { Item: order },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getOrdersByDate(dateDay: string): Promise<Order[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.ordersTable,\n        IndexName: 'by-date',\n        KeyConditionExpression: 'orderDateDay = :dateDay',\n        ExpressionAttributeValues: { ':dateDay': dateDay },\n      })\n    );\n    return (result.Items as Order[]) || [];\n  }\n\n  async getOrdersByChannel(\n    channelName: string,\n    fromDate: string,\n    toDate: string\n  ): Promise<Order[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.ordersTable,\n        IndexName: 'by-channel',\n        KeyConditionExpression: 'channelName = :channel AND orderDate BETWEEN :fromDate AND :toDate',\n        ExpressionAttributeValues: {\n          ':channel': channelName,\n          ':fromDate': fromDate,\n          ':toDate': toDate,\n        },\n      })\n    );\n    return (result.Items as Order[]) || [];\n  }\n\n  async getOrderCount(): Promise<number> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.ordersTable,\n        Select: 'COUNT',\n      })\n    );\n    return result.Count || 0;\n  }\n\n  async getOrder(orderId: string): Promise<Order | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.ordersTable,\n        Key: { orderId },\n      })\n    );\n    return (result.Item as Order) || null;\n  }\n\n  async updateOrderDelivery(\n    orderId: string,\n    deliveryInfo: {\n      deliveryCarrier: string;\n      deliveryCarrierRaw: string;\n      deliveryParcels: number;\n    }\n  ): Promise<void> {\n    await this.docClient.send(\n      new UpdateCommand({\n        TableName: this.ordersTable,\n        Key: { orderId },\n        UpdateExpression: 'SET deliveryCarrier = :carrier, deliveryCarrierRaw = :carrierRaw, deliveryParcels = :parcels, deliveryImportedAt = :importedAt',\n        ExpressionAttributeValues: {\n          ':carrier': deliveryInfo.deliveryCarrier,\n          ':carrierRaw': deliveryInfo.deliveryCarrierRaw,\n          ':parcels': deliveryInfo.deliveryParcels,\n          ':importedAt': new Date().toISOString(),\n        },\n      })\n    );\n  }\n\n  async getAllOrders(): Promise<Order[]> {\n    const orders: Order[] = [];\n    let lastKey: Record<string, unknown> | undefined;\n\n    do {\n      const result = await this.docClient.send(\n        new ScanCommand({\n          TableName: this.ordersTable,\n          ExclusiveStartKey: lastKey,\n        })\n      );\n      if (result.Items) {\n        orders.push(...(result.Items as Order[]));\n      }\n      lastKey = result.LastEvaluatedKey;\n    } while (lastKey);\n\n    return orders;\n  }\n\n  /**\n   * Create a lookup map for products by SKU (case-insensitive) and Balterley SKU\n   * Returns a Map where keys are uppercase SKUs and values are products\n   */\n  async getProductLookupMap(): Promise<{\n    bySku: Map<string, Product>;\n    byBalterleySku: Map<string, Product>;\n  }> {\n    const products = await this.getAllProducts();\n    const bySku = new Map<string, Product>();\n    const byBalterleySku = new Map<string, Product>();\n\n    for (const product of products) {\n      // Primary lookup by SKU (case-insensitive)\n      bySku.set(product.sku.toUpperCase(), product);\n\n      // Secondary lookup by Balterley SKU if available\n      if (product.balterleySku) {\n        byBalterleySku.set(product.balterleySku.toUpperCase(), product);\n      }\n    }\n\n    return { bySku, byBalterleySku };\n  }\n\n  async getSalesBySku(days: number = 7): Promise<Map<string, { quantity: number; revenue: number }>> {\n    const salesMap = new Map<string, { quantity: number; revenue: number }>();\n\n    // Get orders for each day in the range\n    const today = new Date();\n    const dateDays: string[] = [];\n    for (let i = 0; i < days; i++) {\n      const d = new Date(today);\n      d.setDate(d.getDate() - i);\n      dateDays.push(d.toISOString().substring(0, 10));\n    }\n\n    // Query orders for each day and aggregate\n    for (const dateDay of dateDays) {\n      const orders = await this.getOrdersByDate(dateDay);\n      for (const order of orders) {\n        if (order.lines) {\n          for (const line of order.lines) {\n            const existing = salesMap.get(line.sku) || { quantity: 0, revenue: 0 };\n            existing.quantity += line.quantity;\n            existing.revenue += line.lineTotalInclVat;\n            salesMap.set(line.sku, existing);\n          }\n        }\n      }\n    }\n\n    return salesMap;\n  }\n\n  // ============ Utilities ============\n\n  private chunkArray<T>(array: T[], size: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n}\n\n/**\n * Create DynamoDB service from environment variables\n */\nexport function createDynamoDBService(): DynamoDBService {\n  return new DynamoDBService({\n    productsTable: process.env.PRODUCTS_TABLE || 'repricing-products',\n    rulesTable: process.env.PRICING_RULES_TABLE || 'repricing-rules',\n    proposalsTable: process.env.PRICE_PROPOSALS_TABLE || 'repricing-proposals',\n    channelsTable: process.env.CHANNEL_CONFIG_TABLE || 'repricing-channels',\n    ordersTable: process.env.ORDERS_TABLE || 'repricing-orders',\n    carrierCostsTable: process.env.CARRIER_COSTS_TABLE || 'repricing-carrier-costs',\n  });\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "handler", "__toCommonJS", "normalizeCarrierName", "rawCarrier", "lower", "getCarrierDisplayName", "carrierId", "isExcludedCarrier", "import_googleapis", "ChannelEngineService", "config", "endpoint", "method", "body", "queryParams", "params", "key", "value", "url", "response", "errorText", "onBatch", "allProducts", "page", "pageSize", "hasMore", "totalCount", "batchProducts", "product", "error", "fromDate", "toDate", "salesMap", "fromStr", "toStr", "order", "line", "existing", "now", "sevenDaysAgo", "thirtyDaysAgo", "sales7Days", "sales30Days", "allSkus", "sku", "allOrders", "updates", "errors", "i", "chunk", "payload", "createChannelEngineService", "secretArn", "SecretsManagerClient", "GetSecretValueCommand", "secret", "import_uuid", "import_client_dynamodb", "import_lib_dynamodb", "DynamoDBService", "config", "client", "sku", "product", "products", "lastKey", "result", "timestamp", "chunks", "chunk", "brand", "ruleId", "rule", "a", "b", "DeleteCommand", "proposalId", "proposal", "proposals", "status", "filters", "page", "pageSize", "filterExpressions", "expressionAttributeNames", "expressionAttributeValues", "statuses", "items", "term", "p", "totalCount", "startIndex", "reviewedBy", "notes", "approvedPrice", "updateExpressions", "channelId", "channel", "carrierId", "carrier", "carriers", "orders", "order", "dateDay", "channelName", "fromDate", "toDate", "orderId", "deliveryInfo", "bySku", "byBalterleySku", "days", "salesMap", "today", "dateDays", "i", "d", "line", "existing", "array", "size", "createDynamoDBService", "import_uuid", "db", "createDynamoDBService", "handler", "event", "context", "path", "method", "handleProducts", "handleProposals", "handleRules", "handleChannels", "handleAnalytics", "handleImport", "handleCarriers", "handleManualSync", "response", "error", "sku", "products", "product", "body", "existing", "updated", "proposalId", "results", "id", "handlePushPrices", "params", "filters", "page", "pageSize", "result", "proposal", "action", "modifiedPrice", "notes", "reviewedBy", "status", "approvedPrice", "dryRun", "approvedProposals", "modifiedProposals", "allApproved", "updates", "p", "secretArn", "createChannelEngineService", "ruleId", "rules", "rule", "uuid", "channelId", "channels", "channel", "pendingProposals", "summary", "sum", "marginBands", "days", "salesMap", "sales", "value", "key", "csvData", "bySku", "byBalterleySku", "notFound", "matchedByBalterley", "notFoundSkus", "productsToUpdate", "row", "skuUpper", "importedSkuSet", "dbSkusMissingFromFile", "missingCount", "totalDbSkusMissingFromFile", "handleDeliveryImport", "deliveryData", "carrierCosts", "carrierCostMap", "c", "allOrders", "orderByOrderId", "o", "orderByChannelOrderNo", "carriersFound", "excludedCarriers", "ordersProcessed", "ordersMatched", "ordersSkipped", "ordersNotFound", "record", "isExcludedCarrier", "normalizedCarrier", "normalizeCarrierName", "poNumber", "matchedOrder", "basePoNumber", "newCarriers", "carrierId", "newCarrier", "getCarrierDisplayName", "carriers", "carrier", "statusCode"]
}
