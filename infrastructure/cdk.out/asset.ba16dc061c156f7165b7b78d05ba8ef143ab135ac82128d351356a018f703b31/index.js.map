{
  "version": 3,
  "sources": ["../../../packages/lambdas/api/src/index.ts", "../../../packages/core/src/services/google-sheets.ts", "../../../packages/core/src/services/channel-engine.ts", "../../../packages/core/src/services/pricing-engine.ts", "../../../packages/core/src/services/dynamodb.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';\nimport {\n  createDynamoDBService,\n  createChannelEngineService,\n  Product,\n  PricingRule,\n  Channel,\n  ProposalStatus,\n  BulkApprovalRequest,\n} from '@repricing/core';\nimport { v4 as uuid } from 'uuid';\n\nconst db = createDynamoDBService();\n\n/**\n * API Gateway Lambda handler\n * Routes requests to appropriate handlers\n */\nexport async function handler(\n  event: APIGatewayProxyEvent,\n  context: Context\n): Promise<APIGatewayProxyResult> {\n  console.log('API request:', {\n    method: event.httpMethod,\n    path: event.path,\n    requestId: context.awsRequestId,\n  });\n\n  try {\n    const path = event.path;\n    const method = event.httpMethod;\n\n    // Route requests\n    if (path.startsWith('/products')) {\n      return handleProducts(event);\n    }\n    if (path.startsWith('/proposals')) {\n      return handleProposals(event);\n    }\n    if (path.startsWith('/rules')) {\n      return handleRules(event);\n    }\n    if (path.startsWith('/channels')) {\n      return handleChannels(event);\n    }\n    if (path.startsWith('/analytics')) {\n      return handleAnalytics(event);\n    }\n    if (path.startsWith('/import')) {\n      return handleImport(event);\n    }\n    if (path === '/sync' && method === 'POST') {\n      return handleManualSync(event);\n    }\n\n    return response(404, { error: 'Not found' });\n  } catch (error) {\n    console.error('API error:', error);\n    return response(500, {\n      error: error instanceof Error ? error.message : 'Internal server error',\n    });\n  }\n}\n\n// ============ Products ============\n\nasync function handleProducts(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const sku = event.pathParameters?.sku;\n\n  if (method === 'GET' && !sku) {\n    // List all products\n    const products = await db.getAllProducts();\n    return response(200, { items: products, count: products.length });\n  }\n\n  if (method === 'GET' && sku) {\n    // Get single product\n    const product = await db.getProduct(sku);\n    if (!product) {\n      return response(404, { error: 'Product not found' });\n    }\n    return response(200, product);\n  }\n\n  if (method === 'PUT' && sku) {\n    // Update product (costs, delivery)\n    const body = JSON.parse(event.body || '{}');\n    const existing = await db.getProduct(sku);\n\n    if (!existing) {\n      return response(404, { error: 'Product not found' });\n    }\n\n    const updated: Product = {\n      ...existing,\n      costPrice: body.costPrice ?? existing.costPrice,\n      deliveryCost: body.deliveryCost ?? existing.deliveryCost,\n      category: body.category ?? existing.category,\n    };\n\n    await db.putProduct(updated);\n    return response(200, updated);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Proposals ============\n\nasync function handleProposals(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const path = event.path;\n  const proposalId = event.pathParameters?.proposalId;\n\n  // Bulk approve\n  if (path.endsWith('/bulk-approve') && method === 'POST') {\n    const body: BulkApprovalRequest = JSON.parse(event.body || '{}');\n    const results = [];\n\n    for (const id of body.proposalIds) {\n      await db.updateProposalStatus(id, 'approved', body.reviewedBy, body.notes);\n      results.push({ proposalId: id, status: 'approved' });\n    }\n\n    return response(200, { results });\n  }\n\n  // Bulk reject\n  if (path.endsWith('/bulk-reject') && method === 'POST') {\n    const body: BulkApprovalRequest = JSON.parse(event.body || '{}');\n    const results = [];\n\n    for (const id of body.proposalIds) {\n      await db.updateProposalStatus(id, 'rejected', body.reviewedBy, body.notes);\n      results.push({ proposalId: id, status: 'rejected' });\n    }\n\n    return response(200, { results });\n  }\n\n  // Push approved prices to ChannelEngine\n  if (path.endsWith('/push') && method === 'POST') {\n    return handlePushPrices(event);\n  }\n\n  if (method === 'GET' && !proposalId) {\n    // List proposals with filters\n    const params = event.queryStringParameters || {};\n    const filters = {\n      status: params.status as ProposalStatus | undefined,\n      batchId: params.batchId,\n      brand: params.brand,\n      searchTerm: params.search,\n      hasWarnings: params.hasWarnings === 'true',\n    };\n    const page = parseInt(params.page || '1', 10);\n    const pageSize = parseInt(params.pageSize || '50', 10);\n\n    const result = await db.queryProposals(filters, page, pageSize);\n    return response(200, result);\n  }\n\n  if (method === 'GET' && proposalId) {\n    // Get single proposal\n    const proposal = await db.getProposal(proposalId);\n    if (!proposal) {\n      return response(404, { error: 'Proposal not found' });\n    }\n    return response(200, proposal);\n  }\n\n  if (method === 'PUT' && proposalId) {\n    // Update proposal (approve/reject/modify)\n    const body = JSON.parse(event.body || '{}');\n    const { action, modifiedPrice, notes, reviewedBy } = body;\n\n    if (!action || !reviewedBy) {\n      return response(400, { error: 'action and reviewedBy are required' });\n    }\n\n    let status: ProposalStatus;\n    let approvedPrice: number | undefined;\n\n    switch (action) {\n      case 'approve':\n        status = 'approved';\n        break;\n      case 'reject':\n        status = 'rejected';\n        break;\n      case 'modify':\n        if (modifiedPrice === undefined) {\n          return response(400, { error: 'modifiedPrice required for modify action' });\n        }\n        status = 'modified';\n        approvedPrice = modifiedPrice;\n        break;\n      default:\n        return response(400, { error: 'Invalid action' });\n    }\n\n    await db.updateProposalStatus(proposalId, status, reviewedBy, notes, approvedPrice);\n\n    const updated = await db.getProposal(proposalId);\n    return response(200, updated);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\nasync function handlePushPrices(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const body = JSON.parse(event.body || '{}');\n  const dryRun = body.dryRun === true;\n\n  // Get approved proposals\n  const approvedProposals = await db.getProposalsByStatus('approved');\n  const modifiedProposals = await db.getProposalsByStatus('modified');\n  const allApproved = [...approvedProposals, ...modifiedProposals];\n\n  if (allApproved.length === 0) {\n    return response(200, { message: 'No approved proposals to push', count: 0 });\n  }\n\n  // Prepare price updates\n  const updates = allApproved.map((p) => ({\n    merchantProductNo: p.sku,\n    price: p.approvedPrice ?? p.proposedPrice,\n  }));\n\n  if (dryRun) {\n    return response(200, {\n      dryRun: true,\n      count: updates.length,\n      updates,\n    });\n  }\n\n  // Push to ChannelEngine\n  const secretArn = process.env.CHANNEL_ENGINE_SECRET_ARN;\n  if (!secretArn) {\n    return response(500, { error: 'ChannelEngine not configured' });\n  }\n\n  const ceService = await createChannelEngineService(secretArn);\n  const result = await ceService.updatePrices(updates);\n\n  // Update proposal statuses to 'pushed'\n  if (result.success) {\n    for (const proposal of allApproved) {\n      await db.updateProposalStatus(proposal.proposalId, 'pushed', 'system', 'Pushed to ChannelEngine');\n    }\n  }\n\n  return response(200, {\n    success: result.success,\n    pushed: updates.length,\n    errors: result.errors,\n  });\n}\n\n// ============ Rules ============\n\nasync function handleRules(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const ruleId = event.pathParameters?.ruleId;\n\n  if (method === 'GET' && !ruleId) {\n    const rules = await db.getAllRules();\n    return response(200, { items: rules, count: rules.length });\n  }\n\n  if (method === 'GET' && ruleId) {\n    const rule = await db.getRule(ruleId);\n    if (!rule) {\n      return response(404, { error: 'Rule not found' });\n    }\n    return response(200, rule);\n  }\n\n  if (method === 'POST') {\n    const body = JSON.parse(event.body || '{}');\n    const rule: PricingRule = {\n      ruleId: uuid(),\n      name: body.name,\n      description: body.description,\n      priority: body.priority ?? 100,\n      isActive: body.isActive ?? true,\n      conditions: body.conditions || {},\n      action: body.action,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n\n    await db.putRule(rule);\n    return response(201, rule);\n  }\n\n  if (method === 'PUT' && ruleId) {\n    const existing = await db.getRule(ruleId);\n    if (!existing) {\n      return response(404, { error: 'Rule not found' });\n    }\n\n    const body = JSON.parse(event.body || '{}');\n    const updated: PricingRule = {\n      ...existing,\n      name: body.name ?? existing.name,\n      description: body.description ?? existing.description,\n      priority: body.priority ?? existing.priority,\n      isActive: body.isActive ?? existing.isActive,\n      conditions: body.conditions ?? existing.conditions,\n      action: body.action ?? existing.action,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await db.putRule(updated);\n    return response(200, updated);\n  }\n\n  if (method === 'DELETE' && ruleId) {\n    await db.deleteRule(ruleId);\n    return response(204, null);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Channels ============\n\nasync function handleChannels(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const method = event.httpMethod;\n  const channelId = event.pathParameters?.channelId;\n\n  if (method === 'GET' && !channelId) {\n    const channels = await db.getAllChannels();\n    return response(200, { items: channels, count: channels.length });\n  }\n\n  if (method === 'GET' && channelId) {\n    const channel = await db.getChannel(channelId);\n    if (!channel) {\n      return response(404, { error: 'Channel not found' });\n    }\n    return response(200, channel);\n  }\n\n  if (method === 'PUT' && channelId) {\n    const existing = await db.getChannel(channelId);\n    const body = JSON.parse(event.body || '{}');\n\n    const updated: Channel = {\n      channelId: channelId as any,\n      name: body.name ?? existing?.name ?? channelId,\n      isActive: body.isActive ?? existing?.isActive ?? true,\n      commissionPercent: body.commissionPercent ?? existing?.commissionPercent ?? 0,\n      fixedFee: body.fixedFee ?? existing?.fixedFee,\n      paymentProcessingPercent: body.paymentProcessingPercent ?? existing?.paymentProcessingPercent,\n      defaultAcosPercent: body.defaultAcosPercent ?? existing?.defaultAcosPercent,\n      includeAdvertisingInMargin: body.includeAdvertisingInMargin ?? existing?.includeAdvertisingInMargin ?? true,\n      vatPercent: body.vatPercent ?? existing?.vatPercent ?? 20,\n      pricesIncludeVat: body.pricesIncludeVat ?? existing?.pricesIncludeVat ?? true,\n      channelEngineId: body.channelEngineId ?? existing?.channelEngineId,\n      lastUpdated: new Date().toISOString(),\n    };\n\n    await db.putChannel(updated);\n    return response(200, updated);\n  }\n\n  return response(405, { error: 'Method not allowed' });\n}\n\n// ============ Analytics ============\n\nasync function handleAnalytics(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const path = event.path;\n\n  if (path.endsWith('/summary')) {\n    const products = await db.getAllProducts();\n    const pendingProposals = await db.getProposalsByStatus('pending');\n\n    const summary = {\n      totalProducts: products.length,\n      productsWithCosts: products.filter((p) => p.costPrice > 0).length,\n      productsWithoutCosts: products.filter((p) => !p.costPrice || p.costPrice === 0).length,\n      outOfStock: products.filter((p) => p.stockLevel === 0).length,\n      lowStock: products.filter((p) => p.stockLevel > 0 && p.stockLevel < 10).length,\n      pendingProposals: pendingProposals.length,\n      avgMargin:\n        products.length > 0\n          ? products.reduce((sum, p) => sum + (p.calculatedMargin || 0), 0) / products.length\n          : 0,\n    };\n\n    return response(200, summary);\n  }\n\n  if (path.endsWith('/margins')) {\n    const products = await db.getAllProducts();\n\n    // Group by margin bands\n    const marginBands = {\n      negative: products.filter((p) => (p.calculatedMargin || 0) < 0).length,\n      low: products.filter((p) => (p.calculatedMargin || 0) >= 0 && (p.calculatedMargin || 0) < 15).length,\n      target: products.filter((p) => (p.calculatedMargin || 0) >= 15 && (p.calculatedMargin || 0) < 30).length,\n      high: products.filter((p) => (p.calculatedMargin || 0) >= 30).length,\n    };\n\n    return response(200, { marginBands, total: products.length });\n  }\n\n  return response(404, { error: 'Analytics endpoint not found' });\n}\n\n// ============ Import ============\n\nasync function handleImport(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  const path = event.path;\n\n  if (path.endsWith('/costs') && event.httpMethod === 'POST') {\n    // Parse CSV from body\n    const body = JSON.parse(event.body || '{}');\n    const csvData: Array<{ sku: string; costPrice: number; deliveryCost?: number }> = body.data;\n\n    if (!csvData || !Array.isArray(csvData)) {\n      return response(400, { error: 'Invalid data format. Expected { data: [...] }' });\n    }\n\n    let updated = 0;\n    let notFound = 0;\n\n    for (const row of csvData) {\n      const product = await db.getProduct(row.sku);\n      if (product) {\n        product.costPrice = row.costPrice;\n        if (row.deliveryCost !== undefined) {\n          product.deliveryCost = row.deliveryCost;\n        }\n        await db.putProduct(product);\n        updated++;\n      } else {\n        notFound++;\n      }\n    }\n\n    return response(200, {\n      message: 'Cost import complete',\n      updated,\n      notFound,\n      total: csvData.length,\n    });\n  }\n\n  return response(404, { error: 'Import endpoint not found' });\n}\n\n// ============ Manual Sync ============\n\nasync function handleManualSync(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n  // This would trigger the data-sync lambda\n  // For now, return info about how to trigger it\n  return response(200, {\n    message: 'Manual sync not yet implemented. Use AWS Console to invoke data-sync Lambda.',\n  });\n}\n\n// ============ Helpers ============\n\nfunction response(statusCode: number, body: unknown): APIGatewayProxyResult {\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    },\n    body: body ? JSON.stringify(body) : '',\n  };\n}\n", "import { google, sheets_v4 } from 'googleapis';\nimport { GoogleSheetProduct, Product } from '../types';\n\n/**\n * Google Sheets service for reading pricing data\n */\nexport class GoogleSheetsService {\n  private sheets: sheets_v4.Sheets;\n  private spreadsheetId: string;\n\n  constructor(credentials: object, spreadsheetId: string) {\n    const auth = new google.auth.GoogleAuth({\n      credentials,\n      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],\n    });\n\n    this.sheets = google.sheets({ version: 'v4', auth });\n    this.spreadsheetId = spreadsheetId;\n  }\n\n  /**\n   * Fetch all products from the pricing sheet\n   */\n  async fetchProducts(sheetName: string = 'Sheet1'): Promise<GoogleSheetProduct[]> {\n    const response = await this.sheets.spreadsheets.values.get({\n      spreadsheetId: this.spreadsheetId,\n      range: `${sheetName}!A:O`, // Columns A through O based on sheet structure\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    // First row is headers\n    const headers = rows[0];\n    const dataRows = rows.slice(1);\n\n    return dataRows\n      .filter((row) => row[1]) // Must have SKU\n      .map((row) => this.parseRow(row, headers));\n  }\n\n  /**\n   * Parse a single row into a GoogleSheetProduct\n   */\n  private parseRow(row: string[], headers: string[]): GoogleSheetProduct {\n    const getValue = (index: number): string => row[index]?.trim() || '';\n    const getNumber = (index: number): number => {\n      const val = row[index]?.replace(/[\u00A3$,]/g, '').trim();\n      return parseFloat(val) || 0;\n    };\n\n    // Map columns based on known sheet structure\n    // Columns: Brand Name, Product SKU, Balterley SKU, Family Variants, MRP,\n    //          B&Q Pricing, Amazon Pricing, eBay Pricing, ManoMano Pricing, Shopify Pricing,\n    //          (empty), discount-start-date, discount-end-date, discount-price\n    return {\n      brandName: getValue(0),\n      productSku: getValue(1),\n      balterleySku: getValue(2),\n      familyVariants: getValue(3),\n      mrp: getNumber(4),\n      bandqPricing: getNumber(5),\n      amazonPricing: getNumber(6),\n      ebayPricing: getNumber(7),\n      manoManoPricing: getNumber(8),\n      shopifyPricing: getNumber(9),\n      discountStartDate: getValue(11) || undefined,\n      discountEndDate: getValue(12) || undefined,\n      discountPrice: getNumber(13) || undefined,\n    };\n  }\n\n  /**\n   * Transform Google Sheet product to internal Product format\n   * Note: Cost and delivery data must be merged from separate sources\n   */\n  static toProduct(sheetProduct: GoogleSheetProduct): Partial<Product> {\n    // For unified pricing, use Amazon price as the base (most common)\n    // or calculate average of non-zero prices\n    const prices = [\n      sheetProduct.amazonPricing,\n      sheetProduct.ebayPricing,\n      sheetProduct.bandqPricing,\n      sheetProduct.manoManoPricing,\n      sheetProduct.shopifyPricing,\n    ].filter((p) => p > 0);\n\n    const currentPrice = prices.length > 0 ? prices[0] : sheetProduct.mrp;\n\n    return {\n      sku: sheetProduct.productSku,\n      balterleySku: sheetProduct.balterleySku || undefined,\n      title: sheetProduct.productSku, // Will be enriched from ChannelEngine\n      brand: sheetProduct.brandName,\n      familyVariants: sheetProduct.familyVariants || undefined,\n      mrp: sheetProduct.mrp,\n      currentPrice,\n      channelPrices: {\n        amazon: sheetProduct.amazonPricing || undefined,\n        ebay: sheetProduct.ebayPricing || undefined,\n        bandq: sheetProduct.bandqPricing || undefined,\n        manomano: sheetProduct.manoManoPricing || undefined,\n        shopify: sheetProduct.shopifyPricing || undefined,\n      },\n      discountPrice: sheetProduct.discountPrice || undefined,\n      discountStartDate: sheetProduct.discountStartDate || undefined,\n      discountEndDate: sheetProduct.discountEndDate || undefined,\n      lastSyncedFromSheet: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Get sheet metadata to find available sheets\n   */\n  async getSheetNames(): Promise<string[]> {\n    const response = await this.sheets.spreadsheets.get({\n      spreadsheetId: this.spreadsheetId,\n    });\n\n    return response.data.sheets?.map((s) => s.properties?.title || '') || [];\n  }\n}\n\n/**\n * Factory function to create GoogleSheetsService from AWS Secrets\n */\nexport async function createGoogleSheetsService(\n  secretArn: string\n): Promise<GoogleSheetsService> {\n  // Import dynamically to avoid bundling issues\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('Google Sheets secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n  const credentials = JSON.parse(secret.credentials);\n\n  return new GoogleSheetsService(credentials, secret.spreadsheetId);\n}\n", "import { ChannelEngineProduct, ChannelEngineSalesData } from '../types';\n\n/**\n * ChannelEngine API configuration\n */\ninterface ChannelEngineConfig {\n  apiKey: string;\n  tenantId: string;\n  baseUrl?: string;\n}\n\n/**\n * ChannelEngine API response wrapper\n */\ninterface ChannelEngineResponse<T> {\n  Content: T;\n  StatusCode: number;\n  Success: boolean;\n  Message?: string;\n  TotalCount?: number;\n}\n\n/**\n * ChannelEngine product from API\n */\ninterface CEProduct {\n  MerchantProductNo: string;\n  Name: string;\n  Description?: string;\n  Brand?: string;\n  Stock: number;\n  Price: number;\n  CategoryTrail?: string;\n  Ean?: string;\n}\n\n/**\n * ChannelEngine order line item\n */\ninterface CEOrderLine {\n  MerchantProductNo: string;\n  Quantity: number;\n  UnitPriceInclVat: number;\n  OrderDateUtc: string;\n}\n\n/**\n * ChannelEngine service for inventory and sales data\n */\nexport class ChannelEngineService {\n  private apiKey: string;\n  private tenantId: string;\n  private baseUrl: string;\n\n  constructor(config: ChannelEngineConfig) {\n    this.apiKey = config.apiKey;\n    this.tenantId = config.tenantId;\n    this.baseUrl = config.baseUrl || 'https://api.channelengine.net/api/v2';\n  }\n\n  /**\n   * Make authenticated request to ChannelEngine API\n   * Authentication is via apikey query parameter (not header)\n   */\n  private async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST' | 'PUT' = 'GET',\n    body?: unknown,\n    queryParams: Record<string, string | number> = {}\n  ): Promise<ChannelEngineResponse<T>> {\n    // Add API key to query parameters (ChannelEngine's authentication method)\n    const params = new URLSearchParams();\n    params.set('apikey', this.apiKey);\n    for (const [key, value] of Object.entries(queryParams)) {\n      params.set(key, String(value));\n    }\n\n    const url = `${this.baseUrl}${endpoint}?${params.toString()}`;\n\n    const response = await fetch(url, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`ChannelEngine API error: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Fetch all products with full details (stock, price, name, brand, etc.)\n   */\n  async fetchProducts(): Promise<ChannelEngineProduct[]> {\n    const products: ChannelEngineProduct[] = [];\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n\n    while (hasMore) {\n      const response = await this.request<CEProduct[]>(\n        '/products',\n        'GET',\n        undefined,\n        { page, pageSize }\n      );\n\n      if (response.Content && response.Content.length > 0) {\n        for (const product of response.Content) {\n          products.push({\n            merchantProductNo: product.MerchantProductNo,\n            name: product.Name,\n            description: product.Description,\n            brand: product.Brand,\n            ean: product.Ean,\n            stock: product.Stock,\n            price: product.Price,\n            categoryTrail: product.CategoryTrail,\n          });\n        }\n        page++;\n        hasMore = response.Content.length === pageSize;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return products;\n  }\n\n  /**\n   * Fetch sales data for products over a date range\n   */\n  async fetchSalesData(\n    fromDate: Date,\n    toDate: Date\n  ): Promise<Map<string, { quantity: number; revenue: number }>> {\n    const salesMap = new Map<string, { quantity: number; revenue: number }>();\n\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n\n    const fromStr = fromDate.toISOString();\n    const toStr = toDate.toISOString();\n\n    while (hasMore) {\n      const response = await this.request<{ Lines: CEOrderLine[] }[]>(\n        '/orders',\n        'GET',\n        undefined,\n        { fromDate: fromStr, toDate: toStr, page, pageSize }\n      );\n\n      if (response.Content && response.Content.length > 0) {\n        for (const order of response.Content) {\n          if (order.Lines) {\n            for (const line of order.Lines) {\n              const existing = salesMap.get(line.MerchantProductNo) || {\n                quantity: 0,\n                revenue: 0,\n              };\n              existing.quantity += line.Quantity;\n              existing.revenue += line.UnitPriceInclVat * line.Quantity;\n              salesMap.set(line.MerchantProductNo, existing);\n            }\n          }\n        }\n        page++;\n        hasMore = response.Content.length === pageSize;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return salesMap;\n  }\n\n  /**\n   * Calculate sales metrics for last 7 and 30 days\n   */\n  async fetchSalesMetrics(): Promise<ChannelEngineSalesData[]> {\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    const [sales7Days, sales30Days] = await Promise.all([\n      this.fetchSalesData(sevenDaysAgo, now),\n      this.fetchSalesData(thirtyDaysAgo, now),\n    ]);\n\n    // Combine all SKUs from both periods\n    const allSkus = new Set([...sales7Days.keys(), ...sales30Days.keys()]);\n\n    return Array.from(allSkus).map((sku) => ({\n      merchantProductNo: sku,\n      salesLast7Days: sales7Days.get(sku)?.quantity || 0,\n      salesLast30Days: sales30Days.get(sku)?.quantity || 0,\n    }));\n  }\n\n  /**\n   * Update product prices in ChannelEngine\n   */\n  async updatePrices(\n    updates: Array<{ merchantProductNo: string; price: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n\n    // ChannelEngine API typically accepts batch updates\n    // Update in chunks of 100\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Price: u.price,\n        }));\n\n        const response = await this.request<unknown>(\n          '/products/bulk',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Update stock levels in ChannelEngine\n   */\n  async updateStock(\n    updates: Array<{ merchantProductNo: string; stock: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Stock: u.stock,\n        }));\n\n        const response = await this.request<unknown>(\n          '/offer/stock',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n/**\n * Factory function to create ChannelEngineService from AWS Secrets\n */\nexport async function createChannelEngineService(\n  secretArn: string\n): Promise<ChannelEngineService> {\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('ChannelEngine secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n\n  return new ChannelEngineService({\n    apiKey: secret.apiKey,\n    tenantId: secret.tenantId,\n    baseUrl: secret.baseUrl,\n  });\n}\n", "import {\n  Product,\n  Channel,\n  PricingRule,\n  PricingConfig,\n  PriceCalculationResult,\n  CostBreakdown,\n  calculateCostBreakdown,\n  DEFAULT_PRICING_CONFIG,\n  RoundingRule,\n  PriceProposal,\n} from '../types';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Pricing engine - applies rules to calculate optimal prices\n */\nexport class PricingEngine {\n  private config: PricingConfig;\n  private rules: PricingRule[];\n  private channels: Map<string, Channel>;\n\n  constructor(\n    config: PricingConfig = DEFAULT_PRICING_CONFIG,\n    rules: PricingRule[] = [],\n    channels: Channel[] = []\n  ) {\n    this.config = config;\n    this.rules = rules.sort((a, b) => a.priority - b.priority);\n    this.channels = new Map(channels.map((c) => [c.channelId, c]));\n  }\n\n  /**\n   * Calculate proposed price for a product\n   */\n  calculatePrice(product: Product, channelId: string = 'amazon'): PriceCalculationResult {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not configured`);\n    }\n\n    const warnings: string[] = [];\n\n    // Check if product has required cost data\n    if (!product.costPrice || product.costPrice <= 0) {\n      warnings.push('Missing cost price - cannot calculate accurate margin');\n    }\n\n    // Calculate current margin\n    const currentBreakdown = this.calculateCostBreakdown(product, product.currentPrice, channel);\n\n    // Find applicable rule\n    const applicableRule = this.findApplicableRule(product, currentBreakdown);\n\n    // Calculate proposed price\n    let proposedPrice = product.currentPrice;\n    let reason = 'No rule applied - price unchanged';\n\n    if (applicableRule) {\n      const result = this.applyRule(applicableRule, product, channel);\n      proposedPrice = result.price;\n      reason = result.reason;\n    }\n\n    // Apply rounding\n    proposedPrice = this.applyRounding(proposedPrice, this.config.defaultRoundingRule);\n\n    // Enforce floor price (minimum margin)\n    const floorPrice = this.calculateFloorPrice(product, channel);\n    let atFloorPrice = false;\n    if (proposedPrice < floorPrice) {\n      proposedPrice = this.applyRounding(floorPrice, this.config.defaultRoundingRule);\n      warnings.push(`Price raised to floor (${this.config.minimumMarginPercent}% minimum margin)`);\n      atFloorPrice = true;\n    }\n\n    // Enforce ceiling price (MRP or max discount)\n    const ceilingPrice = product.mrp;\n    let atCeilingPrice = false;\n    if (proposedPrice > ceilingPrice) {\n      proposedPrice = ceilingPrice;\n      warnings.push('Price capped at MRP');\n      atCeilingPrice = true;\n    }\n\n    // Calculate final breakdown\n    const proposedBreakdown = this.calculateCostBreakdown(product, proposedPrice, channel);\n\n    // Check if below minimum margin\n    const belowMinimumMargin = proposedBreakdown.marginPercent < this.config.minimumMarginPercent;\n    if (belowMinimumMargin && !atFloorPrice) {\n      warnings.push(\n        `Margin (${proposedBreakdown.marginPercent.toFixed(1)}%) below minimum (${this.config.minimumMarginPercent}%)`\n      );\n    }\n\n    return {\n      sku: product.sku,\n      currentPrice: product.currentPrice,\n      proposedPrice,\n      priceChange: proposedPrice - product.currentPrice,\n      priceChangePercent:\n        product.currentPrice > 0\n          ? ((proposedPrice - product.currentPrice) / product.currentPrice) * 100\n          : 0,\n      currentMargin: currentBreakdown.marginPercent,\n      proposedMargin: proposedBreakdown.marginPercent,\n      marginChange: proposedBreakdown.marginPercent - currentBreakdown.marginPercent,\n      currentProfit: currentBreakdown.netProfit,\n      proposedProfit: proposedBreakdown.netProfit,\n      costBreakdown: proposedBreakdown,\n      appliedRule: applicableRule?.name,\n      reason,\n      warnings,\n      belowMinimumMargin,\n      atFloorPrice,\n      atCeilingPrice,\n    };\n  }\n\n  /**\n   * Calculate cost breakdown for a price\n   */\n  private calculateCostBreakdown(\n    product: Product,\n    price: number,\n    channel: Channel\n  ): CostBreakdown {\n    const advertisingPercent = channel.includeAdvertisingInMargin\n      ? channel.defaultAcosPercent || 0\n      : 0;\n\n    return calculateCostBreakdown(\n      price,\n      product.costPrice || 0,\n      product.deliveryCost || 0,\n      channel.commissionPercent,\n      channel.fixedFee || 0,\n      channel.paymentProcessingPercent || 0,\n      advertisingPercent,\n      channel.vatPercent,\n      channel.pricesIncludeVat\n    );\n  }\n\n  /**\n   * Find the first rule that applies to this product\n   */\n  private findApplicableRule(\n    product: Product,\n    currentBreakdown: CostBreakdown\n  ): PricingRule | undefined {\n    for (const rule of this.rules) {\n      if (!rule.isActive) continue;\n      if (this.ruleMatches(rule, product, currentBreakdown)) {\n        return rule;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if a rule's conditions match the product\n   */\n  private ruleMatches(\n    rule: PricingRule,\n    product: Product,\n    breakdown: CostBreakdown\n  ): boolean {\n    const conditions = rule.conditions;\n\n    // Brand filter\n    if (conditions.brands && conditions.brands.length > 0) {\n      if (!conditions.brands.includes(product.brand)) return false;\n    }\n\n    // Category filter\n    if (conditions.categories && conditions.categories.length > 0) {\n      if (!product.category || !conditions.categories.includes(product.category)) return false;\n    }\n\n    // SKU filter\n    if (conditions.skus && conditions.skus.length > 0) {\n      if (!conditions.skus.includes(product.sku)) return false;\n    }\n\n    // SKU pattern filter\n    if (conditions.skuPatterns && conditions.skuPatterns.length > 0) {\n      const matches = conditions.skuPatterns.some((pattern) =>\n        new RegExp(pattern).test(product.sku)\n      );\n      if (!matches) return false;\n    }\n\n    // Margin conditions\n    if (conditions.marginBelow !== undefined) {\n      if (breakdown.marginPercent >= conditions.marginBelow) return false;\n    }\n    if (conditions.marginAbove !== undefined) {\n      if (breakdown.marginPercent <= conditions.marginAbove) return false;\n    }\n\n    // Stock conditions\n    if (conditions.stockBelow !== undefined) {\n      if (product.stockLevel >= conditions.stockBelow) return false;\n    }\n    if (conditions.stockAbove !== undefined) {\n      if (product.stockLevel <= conditions.stockAbove) return false;\n    }\n\n    // Sales velocity conditions\n    if (conditions.salesVelocityBelow !== undefined) {\n      if (product.salesLast7Days >= conditions.salesVelocityBelow) return false;\n    }\n    if (conditions.salesVelocityAbove !== undefined) {\n      if (product.salesLast7Days <= conditions.salesVelocityAbove) return false;\n    }\n\n    // Price conditions\n    if (conditions.priceBelow !== undefined) {\n      if (product.currentPrice >= conditions.priceBelow) return false;\n    }\n    if (conditions.priceAbove !== undefined) {\n      if (product.currentPrice <= conditions.priceAbove) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Apply a rule's action to calculate new price\n   */\n  private applyRule(\n    rule: PricingRule,\n    product: Product,\n    channel: Channel\n  ): { price: number; reason: string } {\n    const action = rule.action;\n\n    switch (action.type) {\n      case 'set_margin': {\n        // Calculate price to achieve target margin\n        const targetMargin = action.value / 100;\n        const totalCostRate =\n          (channel.commissionPercent +\n            (channel.paymentProcessingPercent || 0) +\n            (channel.defaultAcosPercent || 0)) /\n          100;\n        const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n        // Price = FixedCosts / (1 - totalCostRate - targetMargin)\n        const divisor = 1 - totalCostRate - targetMargin;\n        if (divisor <= 0) {\n          return {\n            price: product.currentPrice,\n            reason: `Cannot achieve ${action.value}% margin - costs too high`,\n          };\n        }\n        const price = fixedCosts / divisor;\n        return {\n          price,\n          reason: `Set to achieve ${action.value}% margin (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_markup': {\n        // Price = Cost \u00D7 Markup multiplier\n        const price = (product.costPrice || 0) * action.value;\n        return {\n          price,\n          reason: `Applied ${action.value}x markup on cost (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_percent': {\n        // Adjust by percentage\n        const price = product.currentPrice * (1 + action.value / 100);\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `${Math.abs(action.value)}% ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_fixed': {\n        // Adjust by fixed amount\n        const price = product.currentPrice + action.value;\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `\u00A3${Math.abs(action.value).toFixed(2)} ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_price': {\n        return {\n          price: action.value,\n          reason: `Set to fixed price \u00A3${action.value.toFixed(2)} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'match_mrp': {\n        return {\n          price: product.mrp,\n          reason: `Set to MRP (rule: ${rule.name})`,\n        };\n      }\n\n      case 'discount_from_mrp': {\n        const price = product.mrp * (1 - action.value / 100);\n        return {\n          price,\n          reason: `${action.value}% discount from MRP (rule: ${rule.name})`,\n        };\n      }\n\n      default:\n        return {\n          price: product.currentPrice,\n          reason: 'Unknown action type',\n        };\n    }\n  }\n\n  /**\n   * Calculate floor price (minimum to achieve minimum margin)\n   */\n  private calculateFloorPrice(product: Product, channel: Channel): number {\n    const targetMargin = this.config.minimumMarginPercent / 100;\n    const totalCostRate =\n      (channel.commissionPercent +\n        (channel.paymentProcessingPercent || 0) +\n        (channel.defaultAcosPercent || 0)) /\n      100;\n    const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n    const divisor = 1 - totalCostRate - targetMargin;\n    if (divisor <= 0) return product.currentPrice;\n\n    return fixedCosts / divisor;\n  }\n\n  /**\n   * Apply rounding rule to price\n   */\n  private applyRounding(price: number, rule: RoundingRule): number {\n    switch (rule) {\n      case 'nearest_99p':\n        return Math.floor(price) + 0.99;\n      case 'nearest_95p':\n        return Math.floor(price) + 0.95;\n      case 'nearest_pound':\n        return Math.round(price);\n      case 'round_down':\n        return Math.floor(price * 100) / 100;\n      case 'round_up':\n        return Math.ceil(price * 100) / 100;\n      case 'none':\n      default:\n        return Math.round(price * 100) / 100;\n    }\n  }\n\n  /**\n   * Generate proposals for all products\n   */\n  generateProposals(products: Product[], batchId: string): PriceProposal[] {\n    const proposals: PriceProposal[] = [];\n\n    for (const product of products) {\n      const result = this.calculatePrice(product);\n\n      // Only create proposal if price changed\n      if (Math.abs(result.priceChange) < 0.01) continue;\n\n      const proposal: PriceProposal = {\n        proposalId: uuid(),\n        sku: product.sku,\n        productTitle: product.title,\n        brand: product.brand,\n        category: product.category,\n        currentPrice: result.currentPrice,\n        proposedPrice: result.proposedPrice,\n        priceChange: result.priceChange,\n        priceChangePercent: result.priceChangePercent,\n        currentMargin: result.currentMargin,\n        proposedMargin: result.proposedMargin,\n        marginChange: result.marginChange,\n        costBreakdown: result.costBreakdown,\n        stockLevel: product.stockLevel,\n        salesLast7Days: product.salesLast7Days,\n        salesLast30Days: product.salesLast30Days,\n        appliedRuleName: result.appliedRule,\n        reason: result.reason,\n        warnings: result.warnings,\n        status: 'pending',\n        createdAt: new Date().toISOString(),\n        batchId,\n        ttl: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60, // 30 days\n      };\n\n      proposals.push(proposal);\n    }\n\n    return proposals;\n  }\n}\n", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport {\n  DynamoDBDocumentClient,\n  GetCommand,\n  PutCommand,\n  QueryCommand,\n  ScanCommand,\n  UpdateCommand,\n  BatchWriteCommand,\n} from '@aws-sdk/lib-dynamodb';\nimport {\n  Product,\n  Channel,\n  PricingRule,\n  PriceProposal,\n  ProposalStatus,\n  ProposalFilters,\n  PaginatedProposals,\n} from '../types';\n\n/**\n * DynamoDB service for all database operations\n */\nexport class DynamoDBService {\n  private docClient: DynamoDBDocumentClient;\n  private productsTable: string;\n  private rulesTable: string;\n  private proposalsTable: string;\n  private channelsTable: string;\n\n  constructor(config: {\n    productsTable: string;\n    rulesTable: string;\n    proposalsTable: string;\n    channelsTable: string;\n  }) {\n    const client = new DynamoDBClient({});\n    this.docClient = DynamoDBDocumentClient.from(client, {\n      marshallOptions: { removeUndefinedValues: true },\n    });\n\n    this.productsTable = config.productsTable;\n    this.rulesTable = config.rulesTable;\n    this.proposalsTable = config.proposalsTable;\n    this.channelsTable = config.channelsTable;\n  }\n\n  // ============ Products ============\n\n  async getProduct(sku: string): Promise<Product | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.productsTable,\n        Key: { sku },\n      })\n    );\n    return (result.Item as Product) || null;\n  }\n\n  async putProduct(product: Product): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.productsTable,\n        Item: { ...product, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllProducts(): Promise<Product[]> {\n    const products: Product[] = [];\n    let lastKey: Record<string, unknown> | undefined;\n\n    do {\n      const result = await this.docClient.send(\n        new ScanCommand({\n          TableName: this.productsTable,\n          ExclusiveStartKey: lastKey,\n        })\n      );\n\n      if (result.Items) {\n        products.push(...(result.Items as Product[]));\n      }\n      lastKey = result.LastEvaluatedKey;\n    } while (lastKey);\n\n    return products;\n  }\n\n  async batchPutProducts(products: Product[]): Promise<void> {\n    const timestamp = new Date().toISOString();\n\n    // DynamoDB batch write limit is 25 items\n    const chunks = this.chunkArray(products, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.productsTable]: chunk.map((product) => ({\n              PutRequest: {\n                Item: { ...product, lastUpdated: timestamp },\n              },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProductsByBrand(brand: string): Promise<Product[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.productsTable,\n        IndexName: 'by-brand',\n        KeyConditionExpression: 'brand = :brand',\n        ExpressionAttributeValues: { ':brand': brand },\n      })\n    );\n    return (result.Items as Product[]) || [];\n  }\n\n  // ============ Pricing Rules ============\n\n  async getRule(ruleId: string): Promise<PricingRule | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n    return (result.Item as PricingRule) || null;\n  }\n\n  async putRule(rule: PricingRule): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.rulesTable,\n        Item: { ...rule, updatedAt: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllRules(): Promise<PricingRule[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.rulesTable,\n      })\n    );\n    return ((result.Items as PricingRule[]) || []).sort((a, b) => a.priority - b.priority);\n  }\n\n  async deleteRule(ruleId: string): Promise<void> {\n    const { DeleteCommand } = await import('@aws-sdk/lib-dynamodb');\n    await this.docClient.send(\n      new DeleteCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n  }\n\n  // ============ Proposals ============\n\n  async getProposal(proposalId: string): Promise<PriceProposal | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n      })\n    );\n    return (result.Item as PriceProposal) || null;\n  }\n\n  async putProposal(proposal: PriceProposal): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.proposalsTable,\n        Item: proposal,\n      })\n    );\n  }\n\n  async batchPutProposals(proposals: PriceProposal[]): Promise<void> {\n    const chunks = this.chunkArray(proposals, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.proposalsTable]: chunk.map((proposal) => ({\n              PutRequest: { Item: proposal },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProposalsByStatus(status: ProposalStatus): Promise<PriceProposal[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.proposalsTable,\n        IndexName: 'by-status',\n        KeyConditionExpression: '#status = :status',\n        ExpressionAttributeNames: { '#status': 'status' },\n        ExpressionAttributeValues: { ':status': status },\n        ScanIndexForward: false, // Most recent first\n      })\n    );\n    return (result.Items as PriceProposal[]) || [];\n  }\n\n  async queryProposals(\n    filters: ProposalFilters,\n    page: number = 1,\n    pageSize: number = 50\n  ): Promise<PaginatedProposals> {\n    // Build filter expression\n    const filterExpressions: string[] = [];\n    const expressionAttributeNames: Record<string, string> = {};\n    const expressionAttributeValues: Record<string, unknown> = {};\n\n    if (filters.status) {\n      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];\n      if (statuses.length === 1) {\n        filterExpressions.push('#status = :status');\n        expressionAttributeNames['#status'] = 'status';\n        expressionAttributeValues[':status'] = statuses[0];\n      }\n    }\n\n    if (filters.brand) {\n      filterExpressions.push('brand = :brand');\n      expressionAttributeValues[':brand'] = filters.brand;\n    }\n\n    if (filters.batchId) {\n      filterExpressions.push('batchId = :batchId');\n      expressionAttributeValues[':batchId'] = filters.batchId;\n    }\n\n    if (filters.hasWarnings) {\n      filterExpressions.push('size(warnings) > :zero');\n      expressionAttributeValues[':zero'] = 0;\n    }\n\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.proposalsTable,\n        FilterExpression: filterExpressions.length > 0 ? filterExpressions.join(' AND ') : undefined,\n        ExpressionAttributeNames:\n          Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,\n        ExpressionAttributeValues:\n          Object.keys(expressionAttributeValues).length > 0 ? expressionAttributeValues : undefined,\n      })\n    );\n\n    let items = (result.Items as PriceProposal[]) || [];\n\n    // Apply search filter (client-side for simplicity)\n    if (filters.searchTerm) {\n      const term = filters.searchTerm.toLowerCase();\n      items = items.filter(\n        (p) =>\n          p.sku.toLowerCase().includes(term) ||\n          p.productTitle.toLowerCase().includes(term)\n      );\n    }\n\n    // Sort by createdAt descending\n    items.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Paginate\n    const totalCount = items.length;\n    const startIndex = (page - 1) * pageSize;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n\n    return {\n      items: paginatedItems,\n      totalCount,\n      page,\n      pageSize,\n      hasMore: startIndex + pageSize < totalCount,\n    };\n  }\n\n  async updateProposalStatus(\n    proposalId: string,\n    status: ProposalStatus,\n    reviewedBy: string,\n    notes?: string,\n    approvedPrice?: number\n  ): Promise<void> {\n    const updateExpressions: string[] = [\n      '#status = :status',\n      'reviewedAt = :reviewedAt',\n      'reviewedBy = :reviewedBy',\n    ];\n    const expressionAttributeNames: Record<string, string> = { '#status': 'status' };\n    const expressionAttributeValues: Record<string, unknown> = {\n      ':status': status,\n      ':reviewedAt': new Date().toISOString(),\n      ':reviewedBy': reviewedBy,\n    };\n\n    if (notes) {\n      updateExpressions.push('reviewNotes = :notes');\n      expressionAttributeValues[':notes'] = notes;\n    }\n\n    if (approvedPrice !== undefined) {\n      updateExpressions.push('approvedPrice = :approvedPrice');\n      expressionAttributeValues[':approvedPrice'] = approvedPrice;\n    }\n\n    await this.docClient.send(\n      new UpdateCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n        UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n        ExpressionAttributeNames: expressionAttributeNames,\n        ExpressionAttributeValues: expressionAttributeValues,\n      })\n    );\n  }\n\n  // ============ Channels ============\n\n  async getChannel(channelId: string): Promise<Channel | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.channelsTable,\n        Key: { channelId },\n      })\n    );\n    return (result.Item as Channel) || null;\n  }\n\n  async putChannel(channel: Channel): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.channelsTable,\n        Item: { ...channel, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllChannels(): Promise<Channel[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.channelsTable,\n      })\n    );\n    return (result.Items as Channel[]) || [];\n  }\n\n  // ============ Utilities ============\n\n  private chunkArray<T>(array: T[], size: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n}\n\n/**\n * Create DynamoDB service from environment variables\n */\nexport function createDynamoDBService(): DynamoDBService {\n  return new DynamoDBService({\n    productsTable: process.env.PRODUCTS_TABLE || 'repricing-products',\n    rulesTable: process.env.PRICING_RULES_TABLE || 'repricing-rules',\n    proposalsTable: process.env.PRICE_PROPOSALS_TABLE || 'repricing-proposals',\n    channelsTable: process.env.CHANNEL_CONFIG_TABLE || 'repricing-channels',\n  });\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "handler", "__toCommonJS", "import_googleapis", "ChannelEngineService", "config", "endpoint", "method", "body", "queryParams", "params", "key", "value", "url", "response", "errorText", "products", "page", "pageSize", "hasMore", "product", "fromDate", "toDate", "salesMap", "fromStr", "toStr", "order", "line", "existing", "now", "sevenDaysAgo", "thirtyDaysAgo", "sales7Days", "sales30Days", "allSkus", "sku", "updates", "errors", "i", "chunk", "payload", "u", "error", "createChannelEngineService", "secretArn", "SecretsManagerClient", "GetSecretValueCommand", "secret", "import_uuid", "import_client_dynamodb", "import_lib_dynamodb", "DynamoDBService", "config", "client", "sku", "product", "products", "lastKey", "result", "timestamp", "chunks", "chunk", "brand", "ruleId", "rule", "a", "b", "DeleteCommand", "proposalId", "proposal", "proposals", "status", "filters", "page", "pageSize", "filterExpressions", "expressionAttributeNames", "expressionAttributeValues", "statuses", "items", "term", "p", "totalCount", "startIndex", "reviewedBy", "notes", "approvedPrice", "updateExpressions", "channelId", "channel", "array", "size", "i", "createDynamoDBService", "import_uuid", "db", "createDynamoDBService", "handler", "event", "context", "path", "method", "handleProducts", "handleProposals", "handleRules", "handleChannels", "handleAnalytics", "handleImport", "handleManualSync", "response", "error", "sku", "products", "product", "body", "existing", "updated", "proposalId", "results", "id", "handlePushPrices", "params", "filters", "page", "pageSize", "result", "proposal", "action", "modifiedPrice", "notes", "reviewedBy", "status", "approvedPrice", "dryRun", "approvedProposals", "modifiedProposals", "allApproved", "updates", "p", "secretArn", "createChannelEngineService", "ruleId", "rules", "rule", "uuid", "channelId", "channels", "channel", "pendingProposals", "summary", "sum", "marginBands", "csvData", "notFound", "row", "statusCode"]
}
