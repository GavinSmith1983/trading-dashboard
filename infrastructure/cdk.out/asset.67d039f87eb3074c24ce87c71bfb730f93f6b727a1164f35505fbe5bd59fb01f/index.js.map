{
  "version": 3,
  "sources": ["../../../packages/lambdas/price-calculator/src/index.ts", "../../../packages/core/src/types/channel.ts", "../../../packages/core/src/types/pricing.ts", "../../../packages/core/src/services/google-sheets.ts", "../../../packages/core/src/services/pricing-engine.ts", "../../../packages/core/src/services/dynamodb.ts"],
  "sourcesContent": ["import { ScheduledEvent, Context } from 'aws-lambda';\nimport { v4 as uuid } from 'uuid';\nimport {\n  createDynamoDBService,\n  PricingEngine,\n  DEFAULT_PRICING_CONFIG,\n  DEFAULT_CHANNEL_CONFIGS,\n  Channel,\n} from '@repricing/core';\n\n/**\n * Price Calculator Lambda\n * Runs weekly after data sync to generate price proposals\n */\nexport async function handler(event: ScheduledEvent, context: Context): Promise<void> {\n  console.log('Starting price calculation', { event, requestId: context.awsRequestId });\n\n  const db = createDynamoDBService();\n  const batchId = uuid();\n\n  try {\n    // 1. Load all products\n    console.log('Loading products...');\n    const products = await db.getAllProducts();\n    console.log(`Loaded ${products.length} products`);\n\n    // Filter to products with cost data (required for margin calculation)\n    const productsWithCosts = products.filter((p) => p.costPrice > 0);\n    console.log(`${productsWithCosts.length} products have cost data`);\n\n    if (productsWithCosts.length === 0) {\n      console.warn('No products with cost data - skipping price calculation');\n      return;\n    }\n\n    // 2. Load pricing rules\n    console.log('Loading pricing rules...');\n    const rules = await db.getAllRules();\n    console.log(`Loaded ${rules.length} pricing rules`);\n\n    // 3. Load channel configuration\n    console.log('Loading channel configuration...');\n    let channels = await db.getAllChannels();\n\n    // If no channels configured, initialize with defaults\n    if (channels.length === 0) {\n      console.log('No channels configured - initializing defaults');\n      const defaultChannels = Object.values(DEFAULT_CHANNEL_CONFIGS).map((c) => ({\n        ...c,\n        lastUpdated: new Date().toISOString(),\n      })) as Channel[];\n\n      for (const channel of defaultChannels) {\n        await db.putChannel(channel);\n      }\n      channels = defaultChannels;\n    }\n\n    // 4. Initialize pricing engine\n    const pricingEngine = new PricingEngine(DEFAULT_PRICING_CONFIG, rules, channels);\n\n    // 5. Generate proposals\n    console.log('Generating price proposals...');\n    const proposals = pricingEngine.generateProposals(productsWithCosts, batchId);\n    console.log(`Generated ${proposals.length} proposals`);\n\n    if (proposals.length === 0) {\n      console.log('No price changes proposed');\n      return;\n    }\n\n    // 6. Save proposals to database\n    console.log('Saving proposals...');\n    await db.batchPutProposals(proposals);\n    console.log('Proposals saved');\n\n    // 7. Log summary\n    const summary = {\n      batchId,\n      totalProducts: products.length,\n      productsWithCosts: productsWithCosts.length,\n      proposalsGenerated: proposals.length,\n      priceIncreases: proposals.filter((p) => p.priceChange > 0).length,\n      priceDecreases: proposals.filter((p) => p.priceChange < 0).length,\n      avgPriceChange:\n        proposals.length > 0\n          ? proposals.reduce((sum, p) => sum + p.priceChangePercent, 0) / proposals.length\n          : 0,\n      avgMarginChange:\n        proposals.length > 0\n          ? proposals.reduce((sum, p) => sum + p.marginChange, 0) / proposals.length\n          : 0,\n      proposalsWithWarnings: proposals.filter((p) => p.warnings.length > 0).length,\n    };\n\n    console.log('Calculation summary:', summary);\n\n    // 8. Could send notification here (SNS, email, etc.)\n    // For now, just log that proposals are ready for review\n    console.log(`Price proposals ready for review. Batch ID: ${batchId}`);\n  } catch (error) {\n    console.error('Price calculation failed:', error);\n    throw error;\n  }\n}\n", "/**\n * Channel configuration - fees and settings per sales channel\n */\nexport interface Channel {\n  channelId: ChannelId;\n  name: string;\n  isActive: boolean;\n\n  // Fee structure\n  commissionPercent: number; // Platform commission (e.g., 15% for Amazon)\n  fixedFee?: number; // Per-transaction fixed fee\n  paymentProcessingPercent?: number; // Payment processing fee (e.g., 2.9% for Shopify)\n\n  // Advertising\n  defaultAcosPercent?: number; // Default advertising cost of sale\n  includeAdvertisingInMargin: boolean; // Whether to factor ads into margin calc\n\n  // VAT handling\n  vatPercent: number; // Usually 20% in UK\n  pricesIncludeVat: boolean;\n\n  // ChannelEngine mapping\n  channelEngineId?: number; // ID in ChannelEngine system\n\n  // Metadata\n  lastUpdated: string;\n}\n\n/**\n * Supported channel identifiers\n */\nexport type ChannelId = 'amazon' | 'ebay' | 'bandq' | 'manomano' | 'shopify';\n\n/**\n * Default channel configurations\n */\nexport const DEFAULT_CHANNEL_CONFIGS: Record<ChannelId, Omit<Channel, 'lastUpdated'>> = {\n  amazon: {\n    channelId: 'amazon',\n    name: 'Amazon UK',\n    isActive: true,\n    commissionPercent: 15,\n    fixedFee: 0,\n    paymentProcessingPercent: 0,\n    defaultAcosPercent: 15,\n    includeAdvertisingInMargin: true,\n    vatPercent: 20,\n    pricesIncludeVat: true,\n  },\n  ebay: {\n    channelId: 'ebay',\n    name: 'eBay UK',\n    isActive: true,\n    commissionPercent: 12.8,\n    fixedFee: 0.30,\n    paymentProcessingPercent: 0,\n    defaultAcosPercent: 10,\n    includeAdvertisingInMargin: true,\n    vatPercent: 20,\n    pricesIncludeVat: true,\n  },\n  bandq: {\n    channelId: 'bandq',\n    name: 'B&Q',\n    isActive: true,\n    commissionPercent: 15, // Adjust based on actual agreement\n    fixedFee: 0,\n    paymentProcessingPercent: 0,\n    defaultAcosPercent: 0,\n    includeAdvertisingInMargin: false,\n    vatPercent: 20,\n    pricesIncludeVat: true,\n  },\n  manomano: {\n    channelId: 'manomano',\n    name: 'ManoMano',\n    isActive: true,\n    commissionPercent: 15, // Adjust based on actual agreement\n    fixedFee: 0,\n    paymentProcessingPercent: 0,\n    defaultAcosPercent: 10,\n    includeAdvertisingInMargin: true,\n    vatPercent: 20,\n    pricesIncludeVat: true,\n  },\n  shopify: {\n    channelId: 'shopify',\n    name: 'Shopify (Direct)',\n    isActive: true,\n    commissionPercent: 0, // No marketplace commission\n    fixedFee: 0,\n    paymentProcessingPercent: 2.9, // Shopify Payments\n    defaultAcosPercent: 5, // Google/Facebook ads\n    includeAdvertisingInMargin: true,\n    vatPercent: 20,\n    pricesIncludeVat: true,\n  },\n};\n\n/**\n * Per-product channel overrides\n */\nexport interface ProductChannelOverride {\n  sku: string;\n  channelId: ChannelId;\n  customAcosPercent?: number; // Override default ACOS for this product\n  customCommissionPercent?: number; // Override commission if negotiated\n  isListed: boolean; // Whether product is listed on this channel\n}\n", "import { ChannelId } from './channel';\n\n/**\n * Pricing rule - defines how prices should be calculated/adjusted\n */\nexport interface PricingRule {\n  ruleId: string;\n  name: string;\n  description?: string;\n  priority: number; // Lower number = higher priority (applied first)\n  isActive: boolean;\n\n  // Conditions - when should this rule apply?\n  conditions: PricingRuleConditions;\n\n  // Action - what should happen when conditions match?\n  action: PricingRuleAction;\n\n  // Metadata\n  createdAt: string;\n  updatedAt: string;\n  createdBy?: string;\n}\n\n/**\n * Conditions that determine when a pricing rule applies\n */\nexport interface PricingRuleConditions {\n  // Product filters\n  brands?: string[]; // Apply to specific brands\n  categories?: string[]; // Apply to specific categories\n  skus?: string[]; // Apply to specific SKUs\n  skuPatterns?: string[]; // Regex patterns for SKUs\n\n  // Margin conditions\n  marginBelow?: number; // Apply if margin is below this %\n  marginAbove?: number; // Apply if margin is above this %\n\n  // Stock conditions\n  stockBelow?: number; // Apply if stock is below this level\n  stockAbove?: number; // Apply if stock is above this level\n\n  // Sales velocity conditions\n  salesVelocityBelow?: number; // Apply if 7-day sales below this\n  salesVelocityAbove?: number; // Apply if 7-day sales above this\n\n  // Price conditions\n  priceBelow?: number; // Apply if current price below this\n  priceAbove?: number; // Apply if current price above this\n}\n\n/**\n * Action to take when rule conditions match\n */\nexport interface PricingRuleAction {\n  type: PricingRuleActionType;\n  value: number;\n  roundingRule?: RoundingRule;\n}\n\n/**\n * Types of pricing actions\n */\nexport type PricingRuleActionType =\n  | 'set_margin' // Set price to achieve target margin %\n  | 'set_markup' // Set price as cost \u00D7 markup multiplier\n  | 'adjust_percent' // Adjust current price by +/- %\n  | 'adjust_fixed' // Adjust current price by +/- fixed amount\n  | 'set_price' // Set to specific price\n  | 'match_mrp' // Set to MRP\n  | 'discount_from_mrp'; // Set to MRP minus % discount\n\n/**\n * Rounding rules for final prices\n */\nexport type RoundingRule =\n  | 'none' // No rounding\n  | 'nearest_99p' // Round to \u00A3X.99\n  | 'nearest_95p' // Round to \u00A3X.95\n  | 'nearest_pound' // Round to nearest \u00A3\n  | 'round_down' // Always round down\n  | 'round_up'; // Always round up\n\n/**\n * Global pricing configuration\n */\nexport interface PricingConfig {\n  // Minimum margin threshold - never price below this\n  minimumMarginPercent: number;\n\n  // Maximum discount from MRP\n  maximumDiscountPercent: number;\n\n  // Default rounding rule\n  defaultRoundingRule: RoundingRule;\n\n  // Whether to include VAT in calculations\n  calculateWithVat: boolean;\n\n  // Whether to include advertising in margin calculations\n  includeAdvertisingInMargin: boolean;\n}\n\n/**\n * Default pricing configuration\n */\nexport const DEFAULT_PRICING_CONFIG: PricingConfig = {\n  minimumMarginPercent: 15,\n  maximumDiscountPercent: 50,\n  defaultRoundingRule: 'nearest_99p',\n  calculateWithVat: true,\n  includeAdvertisingInMargin: true,\n};\n\n/**\n * Result of price calculation for a single product\n */\nexport interface PriceCalculationResult {\n  sku: string;\n  currentPrice: number;\n  proposedPrice: number;\n  priceChange: number;\n  priceChangePercent: number;\n\n  // Margin analysis\n  currentMargin: number;\n  proposedMargin: number;\n  marginChange: number;\n\n  // Profit analysis (per unit)\n  currentProfit: number;\n  proposedProfit: number;\n\n  // Cost breakdown\n  costBreakdown: CostBreakdown;\n\n  // Which rule triggered this change\n  appliedRule?: string;\n  reason: string;\n\n  // Warnings/flags\n  warnings: string[];\n  belowMinimumMargin: boolean;\n  atFloorPrice: boolean;\n  atCeilingPrice: boolean;\n}\n\n/**\n * Detailed cost breakdown for a product\n */\nexport interface CostBreakdown {\n  sellingPrice: number;\n  vatAmount: number;\n  priceExVat: number;\n  costPrice: number;\n  deliveryCost: number;\n  channelCommission: number;\n  channelFixedFee: number;\n  paymentProcessing: number;\n  advertisingCost: number;\n  totalCosts: number;\n  netProfit: number;\n  marginPercent: number;\n}\n\n/**\n * Calculate costs and margin for a given price\n */\nexport function calculateCostBreakdown(\n  sellingPrice: number,\n  costPrice: number,\n  deliveryCost: number,\n  commissionPercent: number,\n  fixedFee: number,\n  paymentProcessingPercent: number,\n  advertisingPercent: number,\n  vatPercent: number,\n  pricesIncludeVat: boolean\n): CostBreakdown {\n  // Calculate VAT\n  const vatMultiplier = 1 + vatPercent / 100;\n  const priceExVat = pricesIncludeVat ? sellingPrice / vatMultiplier : sellingPrice;\n  const vatAmount = pricesIncludeVat ? sellingPrice - priceExVat : 0;\n\n  // Calculate fees (based on selling price inc VAT)\n  const channelCommission = sellingPrice * (commissionPercent / 100);\n  const paymentProcessing = sellingPrice * (paymentProcessingPercent / 100);\n  const advertisingCost = sellingPrice * (advertisingPercent / 100);\n\n  // Total costs\n  const totalCosts =\n    costPrice + deliveryCost + channelCommission + fixedFee + paymentProcessing + advertisingCost;\n\n  // Net profit\n  const netProfit = priceExVat - totalCosts + vatAmount; // VAT is pass-through\n\n  // Actually, let's recalculate - profit is revenue minus all costs\n  // Revenue = selling price (we receive this)\n  // Costs = COGS + delivery + commission + fees + ads\n  // VAT is collected and remitted, so neutral for profit calc\n  const actualProfit = sellingPrice - totalCosts;\n\n  // Margin as percentage of selling price\n  const marginPercent = (actualProfit / sellingPrice) * 100;\n\n  return {\n    sellingPrice,\n    vatAmount,\n    priceExVat,\n    costPrice,\n    deliveryCost,\n    channelCommission,\n    channelFixedFee: fixedFee,\n    paymentProcessing,\n    advertisingCost,\n    totalCosts,\n    netProfit: actualProfit,\n    marginPercent,\n  };\n}\n", "import { google, sheets_v4 } from 'googleapis';\nimport { GoogleSheetProduct, Product } from '../types';\n\n/**\n * Google Sheets service for reading pricing data\n */\nexport class GoogleSheetsService {\n  private sheets: sheets_v4.Sheets;\n  private spreadsheetId: string;\n\n  constructor(credentials: object, spreadsheetId: string) {\n    const auth = new google.auth.GoogleAuth({\n      credentials,\n      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],\n    });\n\n    this.sheets = google.sheets({ version: 'v4', auth });\n    this.spreadsheetId = spreadsheetId;\n  }\n\n  /**\n   * Fetch all products from the pricing sheet\n   */\n  async fetchProducts(sheetName: string = 'Sheet1'): Promise<GoogleSheetProduct[]> {\n    const response = await this.sheets.spreadsheets.values.get({\n      spreadsheetId: this.spreadsheetId,\n      range: `${sheetName}!A:O`, // Columns A through O based on sheet structure\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    // First row is headers\n    const headers = rows[0];\n    const dataRows = rows.slice(1);\n\n    return dataRows\n      .filter((row) => row[1]) // Must have SKU\n      .map((row) => this.parseRow(row, headers));\n  }\n\n  /**\n   * Parse a single row into a GoogleSheetProduct\n   */\n  private parseRow(row: string[], headers: string[]): GoogleSheetProduct {\n    const getValue = (index: number): string => row[index]?.trim() || '';\n    const getNumber = (index: number): number => {\n      const val = row[index]?.replace(/[\u00A3$,]/g, '').trim();\n      return parseFloat(val) || 0;\n    };\n\n    // Map columns based on known sheet structure\n    // Columns: Brand Name, Product SKU, Balterley SKU, Family Variants, MRP,\n    //          B&Q Pricing, Amazon Pricing, eBay Pricing, ManoMano Pricing, Shopify Pricing,\n    //          (empty), discount-start-date, discount-end-date, discount-price\n    return {\n      brandName: getValue(0),\n      productSku: getValue(1),\n      balterleySku: getValue(2),\n      familyVariants: getValue(3),\n      mrp: getNumber(4),\n      bandqPricing: getNumber(5),\n      amazonPricing: getNumber(6),\n      ebayPricing: getNumber(7),\n      manoManoPricing: getNumber(8),\n      shopifyPricing: getNumber(9),\n      discountStartDate: getValue(11) || undefined,\n      discountEndDate: getValue(12) || undefined,\n      discountPrice: getNumber(13) || undefined,\n    };\n  }\n\n  /**\n   * Transform Google Sheet product to internal Product format\n   * Note: Cost and delivery data must be merged from separate sources\n   */\n  static toProduct(sheetProduct: GoogleSheetProduct): Partial<Product> {\n    // For unified pricing, use Amazon price as the base (most common)\n    // or calculate average of non-zero prices\n    const prices = [\n      sheetProduct.amazonPricing,\n      sheetProduct.ebayPricing,\n      sheetProduct.bandqPricing,\n      sheetProduct.manoManoPricing,\n      sheetProduct.shopifyPricing,\n    ].filter((p) => p > 0);\n\n    const currentPrice = prices.length > 0 ? prices[0] : sheetProduct.mrp;\n\n    return {\n      sku: sheetProduct.productSku,\n      balterleySku: sheetProduct.balterleySku || undefined,\n      title: sheetProduct.productSku, // Will be enriched from ChannelEngine\n      brand: sheetProduct.brandName,\n      familyVariants: sheetProduct.familyVariants || undefined,\n      mrp: sheetProduct.mrp,\n      currentPrice,\n      channelPrices: {\n        amazon: sheetProduct.amazonPricing || undefined,\n        ebay: sheetProduct.ebayPricing || undefined,\n        bandq: sheetProduct.bandqPricing || undefined,\n        manomano: sheetProduct.manoManoPricing || undefined,\n        shopify: sheetProduct.shopifyPricing || undefined,\n      },\n      discountPrice: sheetProduct.discountPrice || undefined,\n      discountStartDate: sheetProduct.discountStartDate || undefined,\n      discountEndDate: sheetProduct.discountEndDate || undefined,\n      lastSyncedFromSheet: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Get sheet metadata to find available sheets\n   */\n  async getSheetNames(): Promise<string[]> {\n    const response = await this.sheets.spreadsheets.get({\n      spreadsheetId: this.spreadsheetId,\n    });\n\n    return response.data.sheets?.map((s) => s.properties?.title || '') || [];\n  }\n}\n\n/**\n * Factory function to create GoogleSheetsService from AWS Secrets\n */\nexport async function createGoogleSheetsService(\n  secretArn: string\n): Promise<GoogleSheetsService> {\n  // Import dynamically to avoid bundling issues\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('Google Sheets secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n  const credentials = JSON.parse(secret.credentials);\n\n  return new GoogleSheetsService(credentials, secret.spreadsheetId);\n}\n", "import {\n  Product,\n  Channel,\n  PricingRule,\n  PricingConfig,\n  PriceCalculationResult,\n  CostBreakdown,\n  calculateCostBreakdown,\n  DEFAULT_PRICING_CONFIG,\n  RoundingRule,\n  PriceProposal,\n} from '../types';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Pricing engine - applies rules to calculate optimal prices\n */\nexport class PricingEngine {\n  private config: PricingConfig;\n  private rules: PricingRule[];\n  private channels: Map<string, Channel>;\n\n  constructor(\n    config: PricingConfig = DEFAULT_PRICING_CONFIG,\n    rules: PricingRule[] = [],\n    channels: Channel[] = []\n  ) {\n    this.config = config;\n    this.rules = rules.sort((a, b) => a.priority - b.priority);\n    this.channels = new Map(channels.map((c) => [c.channelId, c]));\n  }\n\n  /**\n   * Calculate proposed price for a product\n   */\n  calculatePrice(product: Product, channelId: string = 'amazon'): PriceCalculationResult {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not configured`);\n    }\n\n    const warnings: string[] = [];\n\n    // Check if product has required cost data\n    if (!product.costPrice || product.costPrice <= 0) {\n      warnings.push('Missing cost price - cannot calculate accurate margin');\n    }\n\n    // Calculate current margin\n    const currentBreakdown = this.calculateCostBreakdown(product, product.currentPrice, channel);\n\n    // Find applicable rule\n    const applicableRule = this.findApplicableRule(product, currentBreakdown);\n\n    // Calculate proposed price\n    let proposedPrice = product.currentPrice;\n    let reason = 'No rule applied - price unchanged';\n\n    if (applicableRule) {\n      const result = this.applyRule(applicableRule, product, channel);\n      proposedPrice = result.price;\n      reason = result.reason;\n    }\n\n    // Apply rounding\n    proposedPrice = this.applyRounding(proposedPrice, this.config.defaultRoundingRule);\n\n    // Enforce floor price (minimum margin)\n    const floorPrice = this.calculateFloorPrice(product, channel);\n    let atFloorPrice = false;\n    if (proposedPrice < floorPrice) {\n      proposedPrice = this.applyRounding(floorPrice, this.config.defaultRoundingRule);\n      warnings.push(`Price raised to floor (${this.config.minimumMarginPercent}% minimum margin)`);\n      atFloorPrice = true;\n    }\n\n    // Enforce ceiling price (MRP or max discount)\n    const ceilingPrice = product.mrp;\n    let atCeilingPrice = false;\n    if (proposedPrice > ceilingPrice) {\n      proposedPrice = ceilingPrice;\n      warnings.push('Price capped at MRP');\n      atCeilingPrice = true;\n    }\n\n    // Calculate final breakdown\n    const proposedBreakdown = this.calculateCostBreakdown(product, proposedPrice, channel);\n\n    // Check if below minimum margin\n    const belowMinimumMargin = proposedBreakdown.marginPercent < this.config.minimumMarginPercent;\n    if (belowMinimumMargin && !atFloorPrice) {\n      warnings.push(\n        `Margin (${proposedBreakdown.marginPercent.toFixed(1)}%) below minimum (${this.config.minimumMarginPercent}%)`\n      );\n    }\n\n    return {\n      sku: product.sku,\n      currentPrice: product.currentPrice,\n      proposedPrice,\n      priceChange: proposedPrice - product.currentPrice,\n      priceChangePercent:\n        product.currentPrice > 0\n          ? ((proposedPrice - product.currentPrice) / product.currentPrice) * 100\n          : 0,\n      currentMargin: currentBreakdown.marginPercent,\n      proposedMargin: proposedBreakdown.marginPercent,\n      marginChange: proposedBreakdown.marginPercent - currentBreakdown.marginPercent,\n      currentProfit: currentBreakdown.netProfit,\n      proposedProfit: proposedBreakdown.netProfit,\n      costBreakdown: proposedBreakdown,\n      appliedRule: applicableRule?.name,\n      reason,\n      warnings,\n      belowMinimumMargin,\n      atFloorPrice,\n      atCeilingPrice,\n    };\n  }\n\n  /**\n   * Calculate cost breakdown for a price\n   */\n  private calculateCostBreakdown(\n    product: Product,\n    price: number,\n    channel: Channel\n  ): CostBreakdown {\n    const advertisingPercent = channel.includeAdvertisingInMargin\n      ? channel.defaultAcosPercent || 0\n      : 0;\n\n    return calculateCostBreakdown(\n      price,\n      product.costPrice || 0,\n      product.deliveryCost || 0,\n      channel.commissionPercent,\n      channel.fixedFee || 0,\n      channel.paymentProcessingPercent || 0,\n      advertisingPercent,\n      channel.vatPercent,\n      channel.pricesIncludeVat\n    );\n  }\n\n  /**\n   * Find the first rule that applies to this product\n   */\n  private findApplicableRule(\n    product: Product,\n    currentBreakdown: CostBreakdown\n  ): PricingRule | undefined {\n    for (const rule of this.rules) {\n      if (!rule.isActive) continue;\n      if (this.ruleMatches(rule, product, currentBreakdown)) {\n        return rule;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if a rule's conditions match the product\n   */\n  private ruleMatches(\n    rule: PricingRule,\n    product: Product,\n    breakdown: CostBreakdown\n  ): boolean {\n    const conditions = rule.conditions;\n\n    // Brand filter\n    if (conditions.brands && conditions.brands.length > 0) {\n      if (!conditions.brands.includes(product.brand)) return false;\n    }\n\n    // Category filter\n    if (conditions.categories && conditions.categories.length > 0) {\n      if (!product.category || !conditions.categories.includes(product.category)) return false;\n    }\n\n    // SKU filter\n    if (conditions.skus && conditions.skus.length > 0) {\n      if (!conditions.skus.includes(product.sku)) return false;\n    }\n\n    // SKU pattern filter\n    if (conditions.skuPatterns && conditions.skuPatterns.length > 0) {\n      const matches = conditions.skuPatterns.some((pattern) =>\n        new RegExp(pattern).test(product.sku)\n      );\n      if (!matches) return false;\n    }\n\n    // Margin conditions\n    if (conditions.marginBelow !== undefined) {\n      if (breakdown.marginPercent >= conditions.marginBelow) return false;\n    }\n    if (conditions.marginAbove !== undefined) {\n      if (breakdown.marginPercent <= conditions.marginAbove) return false;\n    }\n\n    // Stock conditions\n    if (conditions.stockBelow !== undefined) {\n      if (product.stockLevel >= conditions.stockBelow) return false;\n    }\n    if (conditions.stockAbove !== undefined) {\n      if (product.stockLevel <= conditions.stockAbove) return false;\n    }\n\n    // Sales velocity conditions\n    if (conditions.salesVelocityBelow !== undefined) {\n      if (product.salesLast7Days >= conditions.salesVelocityBelow) return false;\n    }\n    if (conditions.salesVelocityAbove !== undefined) {\n      if (product.salesLast7Days <= conditions.salesVelocityAbove) return false;\n    }\n\n    // Price conditions\n    if (conditions.priceBelow !== undefined) {\n      if (product.currentPrice >= conditions.priceBelow) return false;\n    }\n    if (conditions.priceAbove !== undefined) {\n      if (product.currentPrice <= conditions.priceAbove) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Apply a rule's action to calculate new price\n   */\n  private applyRule(\n    rule: PricingRule,\n    product: Product,\n    channel: Channel\n  ): { price: number; reason: string } {\n    const action = rule.action;\n\n    switch (action.type) {\n      case 'set_margin': {\n        // Calculate price to achieve target margin\n        const targetMargin = action.value / 100;\n        const totalCostRate =\n          (channel.commissionPercent +\n            (channel.paymentProcessingPercent || 0) +\n            (channel.defaultAcosPercent || 0)) /\n          100;\n        const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n        // Price = FixedCosts / (1 - totalCostRate - targetMargin)\n        const divisor = 1 - totalCostRate - targetMargin;\n        if (divisor <= 0) {\n          return {\n            price: product.currentPrice,\n            reason: `Cannot achieve ${action.value}% margin - costs too high`,\n          };\n        }\n        const price = fixedCosts / divisor;\n        return {\n          price,\n          reason: `Set to achieve ${action.value}% margin (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_markup': {\n        // Price = Cost \u00D7 Markup multiplier\n        const price = (product.costPrice || 0) * action.value;\n        return {\n          price,\n          reason: `Applied ${action.value}x markup on cost (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_percent': {\n        // Adjust by percentage\n        const price = product.currentPrice * (1 + action.value / 100);\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `${Math.abs(action.value)}% ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_fixed': {\n        // Adjust by fixed amount\n        const price = product.currentPrice + action.value;\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `\u00A3${Math.abs(action.value).toFixed(2)} ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_price': {\n        return {\n          price: action.value,\n          reason: `Set to fixed price \u00A3${action.value.toFixed(2)} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'match_mrp': {\n        return {\n          price: product.mrp,\n          reason: `Set to MRP (rule: ${rule.name})`,\n        };\n      }\n\n      case 'discount_from_mrp': {\n        const price = product.mrp * (1 - action.value / 100);\n        return {\n          price,\n          reason: `${action.value}% discount from MRP (rule: ${rule.name})`,\n        };\n      }\n\n      default:\n        return {\n          price: product.currentPrice,\n          reason: 'Unknown action type',\n        };\n    }\n  }\n\n  /**\n   * Calculate floor price (minimum to achieve minimum margin)\n   */\n  private calculateFloorPrice(product: Product, channel: Channel): number {\n    const targetMargin = this.config.minimumMarginPercent / 100;\n    const totalCostRate =\n      (channel.commissionPercent +\n        (channel.paymentProcessingPercent || 0) +\n        (channel.defaultAcosPercent || 0)) /\n      100;\n    const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n    const divisor = 1 - totalCostRate - targetMargin;\n    if (divisor <= 0) return product.currentPrice;\n\n    return fixedCosts / divisor;\n  }\n\n  /**\n   * Apply rounding rule to price\n   */\n  private applyRounding(price: number, rule: RoundingRule): number {\n    switch (rule) {\n      case 'nearest_99p':\n        return Math.floor(price) + 0.99;\n      case 'nearest_95p':\n        return Math.floor(price) + 0.95;\n      case 'nearest_pound':\n        return Math.round(price);\n      case 'round_down':\n        return Math.floor(price * 100) / 100;\n      case 'round_up':\n        return Math.ceil(price * 100) / 100;\n      case 'none':\n      default:\n        return Math.round(price * 100) / 100;\n    }\n  }\n\n  /**\n   * Generate proposals for all products\n   */\n  generateProposals(products: Product[], batchId: string): PriceProposal[] {\n    const proposals: PriceProposal[] = [];\n\n    for (const product of products) {\n      const result = this.calculatePrice(product);\n\n      // Only create proposal if price changed\n      if (Math.abs(result.priceChange) < 0.01) continue;\n\n      const proposal: PriceProposal = {\n        proposalId: uuid(),\n        sku: product.sku,\n        productTitle: product.title,\n        brand: product.brand,\n        category: product.category,\n        currentPrice: result.currentPrice,\n        proposedPrice: result.proposedPrice,\n        priceChange: result.priceChange,\n        priceChangePercent: result.priceChangePercent,\n        currentMargin: result.currentMargin,\n        proposedMargin: result.proposedMargin,\n        marginChange: result.marginChange,\n        costBreakdown: result.costBreakdown,\n        stockLevel: product.stockLevel,\n        salesLast7Days: product.salesLast7Days,\n        salesLast30Days: product.salesLast30Days,\n        appliedRuleName: result.appliedRule,\n        reason: result.reason,\n        warnings: result.warnings,\n        status: 'pending',\n        createdAt: new Date().toISOString(),\n        batchId,\n        ttl: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60, // 30 days\n      };\n\n      proposals.push(proposal);\n    }\n\n    return proposals;\n  }\n}\n", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport {\n  DynamoDBDocumentClient,\n  GetCommand,\n  PutCommand,\n  QueryCommand,\n  ScanCommand,\n  UpdateCommand,\n  BatchWriteCommand,\n} from '@aws-sdk/lib-dynamodb';\nimport {\n  Product,\n  Channel,\n  PricingRule,\n  PriceProposal,\n  ProposalStatus,\n  ProposalFilters,\n  PaginatedProposals,\n} from '../types';\n\n/**\n * DynamoDB service for all database operations\n */\nexport class DynamoDBService {\n  private docClient: DynamoDBDocumentClient;\n  private productsTable: string;\n  private rulesTable: string;\n  private proposalsTable: string;\n  private channelsTable: string;\n\n  constructor(config: {\n    productsTable: string;\n    rulesTable: string;\n    proposalsTable: string;\n    channelsTable: string;\n  }) {\n    const client = new DynamoDBClient({});\n    this.docClient = DynamoDBDocumentClient.from(client, {\n      marshallOptions: { removeUndefinedValues: true },\n    });\n\n    this.productsTable = config.productsTable;\n    this.rulesTable = config.rulesTable;\n    this.proposalsTable = config.proposalsTable;\n    this.channelsTable = config.channelsTable;\n  }\n\n  // ============ Products ============\n\n  async getProduct(sku: string): Promise<Product | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.productsTable,\n        Key: { sku },\n      })\n    );\n    return (result.Item as Product) || null;\n  }\n\n  async putProduct(product: Product): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.productsTable,\n        Item: { ...product, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllProducts(): Promise<Product[]> {\n    const products: Product[] = [];\n    let lastKey: Record<string, unknown> | undefined;\n\n    do {\n      const result = await this.docClient.send(\n        new ScanCommand({\n          TableName: this.productsTable,\n          ExclusiveStartKey: lastKey,\n        })\n      );\n\n      if (result.Items) {\n        products.push(...(result.Items as Product[]));\n      }\n      lastKey = result.LastEvaluatedKey;\n    } while (lastKey);\n\n    return products;\n  }\n\n  async batchPutProducts(products: Product[]): Promise<void> {\n    const timestamp = new Date().toISOString();\n\n    // DynamoDB batch write limit is 25 items\n    const chunks = this.chunkArray(products, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.productsTable]: chunk.map((product) => ({\n              PutRequest: {\n                Item: { ...product, lastUpdated: timestamp },\n              },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProductsByBrand(brand: string): Promise<Product[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.productsTable,\n        IndexName: 'by-brand',\n        KeyConditionExpression: 'brand = :brand',\n        ExpressionAttributeValues: { ':brand': brand },\n      })\n    );\n    return (result.Items as Product[]) || [];\n  }\n\n  // ============ Pricing Rules ============\n\n  async getRule(ruleId: string): Promise<PricingRule | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n    return (result.Item as PricingRule) || null;\n  }\n\n  async putRule(rule: PricingRule): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.rulesTable,\n        Item: { ...rule, updatedAt: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllRules(): Promise<PricingRule[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.rulesTable,\n      })\n    );\n    return ((result.Items as PricingRule[]) || []).sort((a, b) => a.priority - b.priority);\n  }\n\n  async deleteRule(ruleId: string): Promise<void> {\n    const { DeleteCommand } = await import('@aws-sdk/lib-dynamodb');\n    await this.docClient.send(\n      new DeleteCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n  }\n\n  // ============ Proposals ============\n\n  async getProposal(proposalId: string): Promise<PriceProposal | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n      })\n    );\n    return (result.Item as PriceProposal) || null;\n  }\n\n  async putProposal(proposal: PriceProposal): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.proposalsTable,\n        Item: proposal,\n      })\n    );\n  }\n\n  async batchPutProposals(proposals: PriceProposal[]): Promise<void> {\n    const chunks = this.chunkArray(proposals, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.proposalsTable]: chunk.map((proposal) => ({\n              PutRequest: { Item: proposal },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProposalsByStatus(status: ProposalStatus): Promise<PriceProposal[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.proposalsTable,\n        IndexName: 'by-status',\n        KeyConditionExpression: '#status = :status',\n        ExpressionAttributeNames: { '#status': 'status' },\n        ExpressionAttributeValues: { ':status': status },\n        ScanIndexForward: false, // Most recent first\n      })\n    );\n    return (result.Items as PriceProposal[]) || [];\n  }\n\n  async queryProposals(\n    filters: ProposalFilters,\n    page: number = 1,\n    pageSize: number = 50\n  ): Promise<PaginatedProposals> {\n    // Build filter expression\n    const filterExpressions: string[] = [];\n    const expressionAttributeNames: Record<string, string> = {};\n    const expressionAttributeValues: Record<string, unknown> = {};\n\n    if (filters.status) {\n      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];\n      if (statuses.length === 1) {\n        filterExpressions.push('#status = :status');\n        expressionAttributeNames['#status'] = 'status';\n        expressionAttributeValues[':status'] = statuses[0];\n      }\n    }\n\n    if (filters.brand) {\n      filterExpressions.push('brand = :brand');\n      expressionAttributeValues[':brand'] = filters.brand;\n    }\n\n    if (filters.batchId) {\n      filterExpressions.push('batchId = :batchId');\n      expressionAttributeValues[':batchId'] = filters.batchId;\n    }\n\n    if (filters.hasWarnings) {\n      filterExpressions.push('size(warnings) > :zero');\n      expressionAttributeValues[':zero'] = 0;\n    }\n\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.proposalsTable,\n        FilterExpression: filterExpressions.length > 0 ? filterExpressions.join(' AND ') : undefined,\n        ExpressionAttributeNames:\n          Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,\n        ExpressionAttributeValues:\n          Object.keys(expressionAttributeValues).length > 0 ? expressionAttributeValues : undefined,\n      })\n    );\n\n    let items = (result.Items as PriceProposal[]) || [];\n\n    // Apply search filter (client-side for simplicity)\n    if (filters.searchTerm) {\n      const term = filters.searchTerm.toLowerCase();\n      items = items.filter(\n        (p) =>\n          p.sku.toLowerCase().includes(term) ||\n          p.productTitle.toLowerCase().includes(term)\n      );\n    }\n\n    // Sort by createdAt descending\n    items.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Paginate\n    const totalCount = items.length;\n    const startIndex = (page - 1) * pageSize;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n\n    return {\n      items: paginatedItems,\n      totalCount,\n      page,\n      pageSize,\n      hasMore: startIndex + pageSize < totalCount,\n    };\n  }\n\n  async updateProposalStatus(\n    proposalId: string,\n    status: ProposalStatus,\n    reviewedBy: string,\n    notes?: string,\n    approvedPrice?: number\n  ): Promise<void> {\n    const updateExpressions: string[] = [\n      '#status = :status',\n      'reviewedAt = :reviewedAt',\n      'reviewedBy = :reviewedBy',\n    ];\n    const expressionAttributeNames: Record<string, string> = { '#status': 'status' };\n    const expressionAttributeValues: Record<string, unknown> = {\n      ':status': status,\n      ':reviewedAt': new Date().toISOString(),\n      ':reviewedBy': reviewedBy,\n    };\n\n    if (notes) {\n      updateExpressions.push('reviewNotes = :notes');\n      expressionAttributeValues[':notes'] = notes;\n    }\n\n    if (approvedPrice !== undefined) {\n      updateExpressions.push('approvedPrice = :approvedPrice');\n      expressionAttributeValues[':approvedPrice'] = approvedPrice;\n    }\n\n    await this.docClient.send(\n      new UpdateCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n        UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n        ExpressionAttributeNames: expressionAttributeNames,\n        ExpressionAttributeValues: expressionAttributeValues,\n      })\n    );\n  }\n\n  // ============ Channels ============\n\n  async getChannel(channelId: string): Promise<Channel | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.channelsTable,\n        Key: { channelId },\n      })\n    );\n    return (result.Item as Channel) || null;\n  }\n\n  async putChannel(channel: Channel): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.channelsTable,\n        Item: { ...channel, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllChannels(): Promise<Channel[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.channelsTable,\n      })\n    );\n    return (result.Items as Channel[]) || [];\n  }\n\n  // ============ Utilities ============\n\n  private chunkArray<T>(array: T[], size: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n}\n\n/**\n * Create DynamoDB service from environment variables\n */\nexport function createDynamoDBService(): DynamoDBService {\n  return new DynamoDBService({\n    productsTable: process.env.PRODUCTS_TABLE || 'repricing-products',\n    rulesTable: process.env.PRICING_RULES_TABLE || 'repricing-rules',\n    proposalsTable: process.env.PRICE_PROPOSALS_TABLE || 'repricing-proposals',\n    channelsTable: process.env.CHANNEL_CONFIG_TABLE || 'repricing-channels',\n  });\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "handler", "__toCommonJS", "import_uuid", "DEFAULT_CHANNEL_CONFIGS", "DEFAULT_PRICING_CONFIG", "calculateCostBreakdown", "sellingPrice", "costPrice", "deliveryCost", "commissionPercent", "fixedFee", "paymentProcessingPercent", "advertisingPercent", "vatPercent", "pricesIncludeVat", "vatMultiplier", "priceExVat", "vatAmount", "channelCommission", "paymentProcessing", "advertisingCost", "totalCosts", "netProfit", "actualProfit", "marginPercent", "import_googleapis", "import_uuid", "PricingEngine", "config", "DEFAULT_PRICING_CONFIG", "rules", "channels", "a", "b", "c", "product", "channelId", "channel", "warnings", "currentBreakdown", "applicableRule", "proposedPrice", "reason", "result", "floorPrice", "atFloorPrice", "ceilingPrice", "atCeilingPrice", "proposedBreakdown", "belowMinimumMargin", "price", "advertisingPercent", "calculateCostBreakdown", "rule", "breakdown", "conditions", "pattern", "action", "targetMargin", "totalCostRate", "fixedCosts", "divisor", "direction", "products", "batchId", "proposals", "proposal", "uuid", "import_client_dynamodb", "import_lib_dynamodb", "DynamoDBService", "config", "client", "sku", "product", "products", "lastKey", "result", "timestamp", "chunks", "chunk", "brand", "ruleId", "rule", "a", "b", "DeleteCommand", "proposalId", "proposal", "proposals", "status", "filters", "page", "pageSize", "filterExpressions", "expressionAttributeNames", "expressionAttributeValues", "statuses", "items", "term", "p", "totalCount", "startIndex", "reviewedBy", "notes", "approvedPrice", "updateExpressions", "channelId", "channel", "array", "size", "i", "createDynamoDBService", "handler", "event", "context", "db", "createDynamoDBService", "batchId", "uuid", "products", "productsWithCosts", "p", "rules", "channels", "defaultChannels", "DEFAULT_CHANNEL_CONFIGS", "c", "channel", "pricingEngine", "PricingEngine", "DEFAULT_PRICING_CONFIG", "proposals", "summary", "sum", "error"]
}
