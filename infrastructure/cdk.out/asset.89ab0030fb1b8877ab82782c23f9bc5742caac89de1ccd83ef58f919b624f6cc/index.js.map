{
  "version": 3,
  "sources": ["../../../packages/lambdas/data-sync/src/index.ts", "../../../packages/core/src/services/google-sheets.ts", "../../../packages/core/src/services/channel-engine.ts", "../../../packages/core/src/services/pricing-engine.ts", "../../../packages/core/src/services/dynamodb.ts"],
  "sourcesContent": ["import { ScheduledEvent, Context } from 'aws-lambda';\nimport {\n  createGoogleSheetsService,\n  createChannelEngineService,\n  createDynamoDBService,\n  Product,\n  ChannelEngineProduct,\n  GoogleSheetProduct,\n} from '@repricing/core';\n\n/**\n * Data Sync Lambda\n * Runs weekly to pull data from ChannelEngine (source of truth) and enrich from Google Sheets\n *\n * Data Flow:\n * 1. ChannelEngine \u2192 Primary source: active products, stock, sales, current CE price\n * 2. Google Sheets \u2192 Enrichment: MRP, channel-specific pricing, discounts\n * 3. Cost data is NOT synced here - it's matched at price calculation time from CSV uploads\n */\nexport async function handler(event: ScheduledEvent, context: Context): Promise<void> {\n  console.log('Starting data sync', { event, requestId: context.awsRequestId });\n\n  const db = createDynamoDBService();\n\n  try {\n    // 1. Fetch products from ChannelEngine (PRIMARY SOURCE)\n    console.log('Fetching products from ChannelEngine (primary source)...');\n    const ceProducts = await fetchFromChannelEngine();\n    console.log(`Fetched ${ceProducts.products.length} products from ChannelEngine`);\n\n    // 2. Fetch enrichment data from Google Sheets\n    console.log('Fetching enrichment data from Google Sheets...');\n    const sheetData = await fetchFromGoogleSheets();\n    console.log(`Fetched ${sheetData.size} products from Google Sheets for enrichment`);\n\n    // 3. Get existing products from DB (to preserve cost data)\n    console.log('Loading existing products from database...');\n    const existingProducts = await db.getAllProducts();\n    const existingMap = new Map(existingProducts.map((p) => [p.sku, p]));\n    console.log(`Found ${existingProducts.length} existing products`);\n\n    // 4. Build product records: CE as base, enrich with Sheets, preserve costs from DB\n    console.log('Building product records...');\n    const products = buildProducts(ceProducts, sheetData, existingMap);\n    console.log(`Built ${products.length} product records`);\n\n    // 5. Save to database\n    console.log('Saving to database...');\n    await db.batchPutProducts(products);\n    console.log('Data sync complete');\n\n    // 6. Log summary\n    const enrichedCount = products.filter(p => sheetData.has(p.sku)).length;\n    const withCostCount = products.filter(p => p.costPrice > 0).length;\n    const summary = {\n      totalProducts: products.length,\n      fromChannelEngine: ceProducts.products.length,\n      enrichedFromSheet: enrichedCount,\n      withSalesData: ceProducts.salesMap.size,\n      withCostData: withCostCount,\n      newProducts: products.filter((p) => !existingMap.has(p.sku)).length,\n      updatedProducts: products.filter((p) => existingMap.has(p.sku)).length,\n    };\n    console.log('Sync summary:', summary);\n  } catch (error) {\n    console.error('Data sync failed:', error);\n    throw error;\n  }\n}\n\n/**\n * Fetch products and sales data from ChannelEngine (PRIMARY SOURCE)\n */\nasync function fetchFromChannelEngine(): Promise<{\n  products: ChannelEngineProduct[];\n  salesMap: Map<string, { salesLast7Days: number; salesLast30Days: number }>;\n}> {\n  const secretArn = process.env.CHANNEL_ENGINE_SECRET_ARN;\n  if (!secretArn) {\n    throw new Error('CHANNEL_ENGINE_SECRET_ARN not configured - ChannelEngine is required as primary data source');\n  }\n\n  const ceService = await createChannelEngineService(secretArn);\n\n  // Fetch all products with full details\n  const products = await ceService.fetchProducts();\n\n  // Fetch sales metrics\n  const salesMetrics = await ceService.fetchSalesMetrics();\n  const salesMap = new Map(\n    salesMetrics.map((s) => [\n      s.merchantProductNo,\n      { salesLast7Days: s.salesLast7Days, salesLast30Days: s.salesLast30Days },\n    ])\n  );\n\n  return { products, salesMap };\n}\n\n/**\n * Fetch enrichment data from Google Sheets (MRP, channel pricing, discounts)\n * Returns a Map keyed by SKU for easy lookup\n */\nasync function fetchFromGoogleSheets(): Promise<Map<string, GoogleSheetProduct>> {\n  const secretArn = process.env.GOOGLE_SHEETS_SECRET_ARN;\n  if (!secretArn) {\n    console.warn('GOOGLE_SHEETS_SECRET_ARN not configured - skipping Sheets enrichment');\n    return new Map();\n  }\n\n  try {\n    const sheetsService = await createGoogleSheetsService(secretArn);\n    const sheetProducts = await sheetsService.fetchProducts();\n\n    // Create lookup map by SKU\n    const map = new Map<string, GoogleSheetProduct>();\n    for (const product of sheetProducts) {\n      if (product.productSku) {\n        map.set(product.productSku, product);\n      }\n    }\n    return map;\n  } catch (error) {\n    console.error('Google Sheets fetch failed:', error);\n    return new Map();\n  }\n}\n\n/**\n * Build Product records from ChannelEngine (base) + Google Sheets (enrichment) + existing DB (costs)\n */\nfunction buildProducts(\n  ceData: {\n    products: ChannelEngineProduct[];\n    salesMap: Map<string, { salesLast7Days: number; salesLast30Days: number }>;\n  },\n  sheetData: Map<string, GoogleSheetProduct>,\n  existingProducts: Map<string, Product>\n): Product[] {\n  const timestamp = new Date().toISOString();\n  const products: Product[] = [];\n\n  // Iterate over ChannelEngine products (source of truth for active products)\n  for (const ceProduct of ceData.products) {\n    const sku = ceProduct.merchantProductNo;\n    const existing = existingProducts.get(sku);\n    const sheetProduct = sheetData.get(sku);\n    const sales = ceData.salesMap.get(sku);\n\n    // Determine current price: prefer sheet pricing, fallback to CE price\n    const channelPrices = sheetProduct ? {\n      amazon: sheetProduct.amazonPricing || undefined,\n      ebay: sheetProduct.ebayPricing || undefined,\n      bandq: sheetProduct.bandqPricing || undefined,\n      manomano: sheetProduct.manoManoPricing || undefined,\n      shopify: sheetProduct.shopifyPricing || undefined,\n    } : undefined;\n\n    // Use the first non-zero channel price or CE price as current price\n    const sheetPrices = [\n      sheetProduct?.amazonPricing,\n      sheetProduct?.ebayPricing,\n      sheetProduct?.bandqPricing,\n      sheetProduct?.manoManoPricing,\n      sheetProduct?.shopifyPricing,\n    ].filter((p): p is number => p !== undefined && p > 0);\n\n    const currentPrice = sheetPrices.length > 0 ? sheetPrices[0] : ceProduct.price;\n\n    const product: Product = {\n      // Core identifiers from ChannelEngine\n      sku,\n      title: ceProduct.name || sku,\n      brand: sheetProduct?.brandName || ceProduct.brand || '',\n      category: ceProduct.categoryTrail,\n\n      // Enrichment from Google Sheets\n      balterleySku: sheetProduct?.balterleySku || existing?.balterleySku,\n      familyVariants: sheetProduct?.familyVariants || existing?.familyVariants,\n      mrp: sheetProduct?.mrp || existing?.mrp || 0,\n      currentPrice,\n      channelPrices,\n\n      // Discount info from Sheets\n      discountPrice: sheetProduct?.discountPrice,\n      discountStartDate: sheetProduct?.discountStartDate,\n      discountEndDate: sheetProduct?.discountEndDate,\n\n      // Cost data preserved from existing DB (updated via CSV import)\n      costPrice: existing?.costPrice || 0,\n      deliveryCost: existing?.deliveryCost || 0,\n\n      // Stock from ChannelEngine\n      stockLevel: ceProduct.stock,\n      stockLastUpdated: timestamp,\n\n      // Sales from ChannelEngine\n      salesLast7Days: sales?.salesLast7Days || 0,\n      salesLast30Days: sales?.salesLast30Days || 0,\n      salesLastUpdated: sales ? timestamp : existing?.salesLastUpdated,\n\n      // Timestamps\n      lastUpdated: timestamp,\n      lastSyncedFromSheet: sheetProduct ? timestamp : existing?.lastSyncedFromSheet,\n      lastSyncedFromChannelEngine: timestamp,\n    };\n\n    products.push(product);\n  }\n\n  return products;\n}\n", "import { google, sheets_v4 } from 'googleapis';\nimport { GoogleSheetProduct, Product } from '../types';\n\n/**\n * Google Sheets service for reading pricing data\n */\nexport class GoogleSheetsService {\n  private sheets: sheets_v4.Sheets;\n  private spreadsheetId: string;\n\n  constructor(credentials: object, spreadsheetId: string) {\n    const auth = new google.auth.GoogleAuth({\n      credentials,\n      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],\n    });\n\n    this.sheets = google.sheets({ version: 'v4', auth });\n    this.spreadsheetId = spreadsheetId;\n  }\n\n  /**\n   * Fetch all products from the pricing sheet\n   */\n  async fetchProducts(sheetName: string = 'Sheet1'): Promise<GoogleSheetProduct[]> {\n    const response = await this.sheets.spreadsheets.values.get({\n      spreadsheetId: this.spreadsheetId,\n      range: `${sheetName}!A:O`, // Columns A through O based on sheet structure\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    // First row is headers\n    const headers = rows[0];\n    const dataRows = rows.slice(1);\n\n    return dataRows\n      .filter((row) => row[1]) // Must have SKU\n      .map((row) => this.parseRow(row, headers));\n  }\n\n  /**\n   * Parse a single row into a GoogleSheetProduct\n   */\n  private parseRow(row: string[], headers: string[]): GoogleSheetProduct {\n    const getValue = (index: number): string => row[index]?.trim() || '';\n    const getNumber = (index: number): number => {\n      const val = row[index]?.replace(/[\u00A3$,]/g, '').trim();\n      return parseFloat(val) || 0;\n    };\n\n    // Map columns based on known sheet structure\n    // Columns: Brand Name, Product SKU, Balterley SKU, Family Variants, MRP,\n    //          B&Q Pricing, Amazon Pricing, eBay Pricing, ManoMano Pricing, Shopify Pricing,\n    //          (empty), discount-start-date, discount-end-date, discount-price\n    return {\n      brandName: getValue(0),\n      productSku: getValue(1),\n      balterleySku: getValue(2),\n      familyVariants: getValue(3),\n      mrp: getNumber(4),\n      bandqPricing: getNumber(5),\n      amazonPricing: getNumber(6),\n      ebayPricing: getNumber(7),\n      manoManoPricing: getNumber(8),\n      shopifyPricing: getNumber(9),\n      discountStartDate: getValue(11) || undefined,\n      discountEndDate: getValue(12) || undefined,\n      discountPrice: getNumber(13) || undefined,\n    };\n  }\n\n  /**\n   * Transform Google Sheet product to internal Product format\n   * Note: Cost and delivery data must be merged from separate sources\n   */\n  static toProduct(sheetProduct: GoogleSheetProduct): Partial<Product> {\n    // For unified pricing, use Amazon price as the base (most common)\n    // or calculate average of non-zero prices\n    const prices = [\n      sheetProduct.amazonPricing,\n      sheetProduct.ebayPricing,\n      sheetProduct.bandqPricing,\n      sheetProduct.manoManoPricing,\n      sheetProduct.shopifyPricing,\n    ].filter((p) => p > 0);\n\n    const currentPrice = prices.length > 0 ? prices[0] : sheetProduct.mrp;\n\n    return {\n      sku: sheetProduct.productSku,\n      balterleySku: sheetProduct.balterleySku || undefined,\n      title: sheetProduct.productSku, // Will be enriched from ChannelEngine\n      brand: sheetProduct.brandName,\n      familyVariants: sheetProduct.familyVariants || undefined,\n      mrp: sheetProduct.mrp,\n      currentPrice,\n      channelPrices: {\n        amazon: sheetProduct.amazonPricing || undefined,\n        ebay: sheetProduct.ebayPricing || undefined,\n        bandq: sheetProduct.bandqPricing || undefined,\n        manomano: sheetProduct.manoManoPricing || undefined,\n        shopify: sheetProduct.shopifyPricing || undefined,\n      },\n      discountPrice: sheetProduct.discountPrice || undefined,\n      discountStartDate: sheetProduct.discountStartDate || undefined,\n      discountEndDate: sheetProduct.discountEndDate || undefined,\n      lastSyncedFromSheet: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Get sheet metadata to find available sheets\n   */\n  async getSheetNames(): Promise<string[]> {\n    const response = await this.sheets.spreadsheets.get({\n      spreadsheetId: this.spreadsheetId,\n    });\n\n    return response.data.sheets?.map((s) => s.properties?.title || '') || [];\n  }\n}\n\n/**\n * Factory function to create GoogleSheetsService from AWS Secrets\n */\nexport async function createGoogleSheetsService(\n  secretArn: string\n): Promise<GoogleSheetsService> {\n  // Import dynamically to avoid bundling issues\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('Google Sheets secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n  const credentials = JSON.parse(secret.credentials);\n\n  return new GoogleSheetsService(credentials, secret.spreadsheetId);\n}\n", "import { ChannelEngineProduct, ChannelEngineSalesData } from '../types';\n\n/**\n * ChannelEngine API configuration\n */\ninterface ChannelEngineConfig {\n  apiKey: string;\n  tenantId: string;\n  baseUrl?: string;\n}\n\n/**\n * ChannelEngine API response wrapper\n */\ninterface ChannelEngineResponse<T> {\n  Content: T;\n  StatusCode: number;\n  Success: boolean;\n  Message?: string;\n  TotalCount?: number;\n}\n\n/**\n * ChannelEngine product from API\n */\ninterface CEProduct {\n  MerchantProductNo: string;\n  Name: string;\n  Description?: string;\n  Brand?: string;\n  Stock: number;\n  Price: number;\n  CategoryTrail?: string;\n  Ean?: string;\n}\n\n/**\n * ChannelEngine order line item\n */\ninterface CEOrderLine {\n  MerchantProductNo: string;\n  Quantity: number;\n  UnitPriceInclVat: number;\n  OrderDateUtc: string;\n}\n\n/**\n * ChannelEngine service for inventory and sales data\n */\nexport class ChannelEngineService {\n  private apiKey: string;\n  private tenantId: string;\n  private baseUrl: string;\n\n  constructor(config: ChannelEngineConfig) {\n    this.apiKey = config.apiKey;\n    this.tenantId = config.tenantId;\n    this.baseUrl = config.baseUrl || 'https://api.channelengine.net/api/v2';\n  }\n\n  /**\n   * Make authenticated request to ChannelEngine API\n   * Authentication is via apikey query parameter (not header)\n   */\n  private async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST' | 'PUT' = 'GET',\n    body?: unknown,\n    queryParams: Record<string, string | number> = {}\n  ): Promise<ChannelEngineResponse<T>> {\n    // Add API key to query parameters (ChannelEngine's authentication method)\n    const params = new URLSearchParams();\n    params.set('apikey', this.apiKey);\n    for (const [key, value] of Object.entries(queryParams)) {\n      params.set(key, String(value));\n    }\n\n    const url = `${this.baseUrl}${endpoint}?${params.toString()}`;\n\n    const response = await fetch(url, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`ChannelEngine API error: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Fetch all products with full details (stock, price, name, brand, etc.)\n   */\n  async fetchProducts(): Promise<ChannelEngineProduct[]> {\n    const products: ChannelEngineProduct[] = [];\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n\n    while (hasMore) {\n      const response = await this.request<CEProduct[]>(\n        '/products',\n        'GET',\n        undefined,\n        { page, pageSize }\n      );\n\n      if (response.Content && response.Content.length > 0) {\n        for (const product of response.Content) {\n          products.push({\n            merchantProductNo: product.MerchantProductNo,\n            name: product.Name,\n            description: product.Description,\n            brand: product.Brand,\n            ean: product.Ean,\n            stock: product.Stock,\n            price: product.Price,\n            categoryTrail: product.CategoryTrail,\n          });\n        }\n        page++;\n        hasMore = response.Content.length === pageSize;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return products;\n  }\n\n  /**\n   * Fetch sales data for products over a date range\n   */\n  async fetchSalesData(\n    fromDate: Date,\n    toDate: Date\n  ): Promise<Map<string, { quantity: number; revenue: number }>> {\n    const salesMap = new Map<string, { quantity: number; revenue: number }>();\n\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n\n    const fromStr = fromDate.toISOString();\n    const toStr = toDate.toISOString();\n\n    while (hasMore) {\n      const response = await this.request<{ Lines: CEOrderLine[] }[]>(\n        '/orders',\n        'GET',\n        undefined,\n        { fromDate: fromStr, toDate: toStr, page, pageSize }\n      );\n\n      if (response.Content && response.Content.length > 0) {\n        for (const order of response.Content) {\n          if (order.Lines) {\n            for (const line of order.Lines) {\n              const existing = salesMap.get(line.MerchantProductNo) || {\n                quantity: 0,\n                revenue: 0,\n              };\n              existing.quantity += line.Quantity;\n              existing.revenue += line.UnitPriceInclVat * line.Quantity;\n              salesMap.set(line.MerchantProductNo, existing);\n            }\n          }\n        }\n        page++;\n        hasMore = response.Content.length === pageSize;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return salesMap;\n  }\n\n  /**\n   * Calculate sales metrics for last 7 and 30 days\n   */\n  async fetchSalesMetrics(): Promise<ChannelEngineSalesData[]> {\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    const [sales7Days, sales30Days] = await Promise.all([\n      this.fetchSalesData(sevenDaysAgo, now),\n      this.fetchSalesData(thirtyDaysAgo, now),\n    ]);\n\n    // Combine all SKUs from both periods\n    const allSkus = new Set([...sales7Days.keys(), ...sales30Days.keys()]);\n\n    return Array.from(allSkus).map((sku) => ({\n      merchantProductNo: sku,\n      salesLast7Days: sales7Days.get(sku)?.quantity || 0,\n      salesLast30Days: sales30Days.get(sku)?.quantity || 0,\n    }));\n  }\n\n  /**\n   * Update product prices in ChannelEngine\n   */\n  async updatePrices(\n    updates: Array<{ merchantProductNo: string; price: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n\n    // ChannelEngine API typically accepts batch updates\n    // Update in chunks of 100\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Price: u.price,\n        }));\n\n        const response = await this.request<unknown>(\n          '/products/bulk',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Update stock levels in ChannelEngine\n   */\n  async updateStock(\n    updates: Array<{ merchantProductNo: string; stock: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Stock: u.stock,\n        }));\n\n        const response = await this.request<unknown>(\n          '/offer/stock',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n/**\n * Factory function to create ChannelEngineService from AWS Secrets\n */\nexport async function createChannelEngineService(\n  secretArn: string\n): Promise<ChannelEngineService> {\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('ChannelEngine secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n\n  return new ChannelEngineService({\n    apiKey: secret.apiKey,\n    tenantId: secret.tenantId,\n    baseUrl: secret.baseUrl,\n  });\n}\n", "import {\n  Product,\n  Channel,\n  PricingRule,\n  PricingConfig,\n  PriceCalculationResult,\n  CostBreakdown,\n  calculateCostBreakdown,\n  DEFAULT_PRICING_CONFIG,\n  RoundingRule,\n  PriceProposal,\n} from '../types';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Pricing engine - applies rules to calculate optimal prices\n */\nexport class PricingEngine {\n  private config: PricingConfig;\n  private rules: PricingRule[];\n  private channels: Map<string, Channel>;\n\n  constructor(\n    config: PricingConfig = DEFAULT_PRICING_CONFIG,\n    rules: PricingRule[] = [],\n    channels: Channel[] = []\n  ) {\n    this.config = config;\n    this.rules = rules.sort((a, b) => a.priority - b.priority);\n    this.channels = new Map(channels.map((c) => [c.channelId, c]));\n  }\n\n  /**\n   * Calculate proposed price for a product\n   */\n  calculatePrice(product: Product, channelId: string = 'amazon'): PriceCalculationResult {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not configured`);\n    }\n\n    const warnings: string[] = [];\n\n    // Check if product has required cost data\n    if (!product.costPrice || product.costPrice <= 0) {\n      warnings.push('Missing cost price - cannot calculate accurate margin');\n    }\n\n    // Calculate current margin\n    const currentBreakdown = this.calculateCostBreakdown(product, product.currentPrice, channel);\n\n    // Find applicable rule\n    const applicableRule = this.findApplicableRule(product, currentBreakdown);\n\n    // Calculate proposed price\n    let proposedPrice = product.currentPrice;\n    let reason = 'No rule applied - price unchanged';\n\n    if (applicableRule) {\n      const result = this.applyRule(applicableRule, product, channel);\n      proposedPrice = result.price;\n      reason = result.reason;\n    }\n\n    // Apply rounding\n    proposedPrice = this.applyRounding(proposedPrice, this.config.defaultRoundingRule);\n\n    // Enforce floor price (minimum margin)\n    const floorPrice = this.calculateFloorPrice(product, channel);\n    let atFloorPrice = false;\n    if (proposedPrice < floorPrice) {\n      proposedPrice = this.applyRounding(floorPrice, this.config.defaultRoundingRule);\n      warnings.push(`Price raised to floor (${this.config.minimumMarginPercent}% minimum margin)`);\n      atFloorPrice = true;\n    }\n\n    // Enforce ceiling price (MRP or max discount)\n    const ceilingPrice = product.mrp;\n    let atCeilingPrice = false;\n    if (proposedPrice > ceilingPrice) {\n      proposedPrice = ceilingPrice;\n      warnings.push('Price capped at MRP');\n      atCeilingPrice = true;\n    }\n\n    // Calculate final breakdown\n    const proposedBreakdown = this.calculateCostBreakdown(product, proposedPrice, channel);\n\n    // Check if below minimum margin\n    const belowMinimumMargin = proposedBreakdown.marginPercent < this.config.minimumMarginPercent;\n    if (belowMinimumMargin && !atFloorPrice) {\n      warnings.push(\n        `Margin (${proposedBreakdown.marginPercent.toFixed(1)}%) below minimum (${this.config.minimumMarginPercent}%)`\n      );\n    }\n\n    return {\n      sku: product.sku,\n      currentPrice: product.currentPrice,\n      proposedPrice,\n      priceChange: proposedPrice - product.currentPrice,\n      priceChangePercent:\n        product.currentPrice > 0\n          ? ((proposedPrice - product.currentPrice) / product.currentPrice) * 100\n          : 0,\n      currentMargin: currentBreakdown.marginPercent,\n      proposedMargin: proposedBreakdown.marginPercent,\n      marginChange: proposedBreakdown.marginPercent - currentBreakdown.marginPercent,\n      currentProfit: currentBreakdown.netProfit,\n      proposedProfit: proposedBreakdown.netProfit,\n      costBreakdown: proposedBreakdown,\n      appliedRule: applicableRule?.name,\n      reason,\n      warnings,\n      belowMinimumMargin,\n      atFloorPrice,\n      atCeilingPrice,\n    };\n  }\n\n  /**\n   * Calculate cost breakdown for a price\n   */\n  private calculateCostBreakdown(\n    product: Product,\n    price: number,\n    channel: Channel\n  ): CostBreakdown {\n    const advertisingPercent = channel.includeAdvertisingInMargin\n      ? channel.defaultAcosPercent || 0\n      : 0;\n\n    return calculateCostBreakdown(\n      price,\n      product.costPrice || 0,\n      product.deliveryCost || 0,\n      channel.commissionPercent,\n      channel.fixedFee || 0,\n      channel.paymentProcessingPercent || 0,\n      advertisingPercent,\n      channel.vatPercent,\n      channel.pricesIncludeVat\n    );\n  }\n\n  /**\n   * Find the first rule that applies to this product\n   */\n  private findApplicableRule(\n    product: Product,\n    currentBreakdown: CostBreakdown\n  ): PricingRule | undefined {\n    for (const rule of this.rules) {\n      if (!rule.isActive) continue;\n      if (this.ruleMatches(rule, product, currentBreakdown)) {\n        return rule;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if a rule's conditions match the product\n   */\n  private ruleMatches(\n    rule: PricingRule,\n    product: Product,\n    breakdown: CostBreakdown\n  ): boolean {\n    const conditions = rule.conditions;\n\n    // Brand filter\n    if (conditions.brands && conditions.brands.length > 0) {\n      if (!conditions.brands.includes(product.brand)) return false;\n    }\n\n    // Category filter\n    if (conditions.categories && conditions.categories.length > 0) {\n      if (!product.category || !conditions.categories.includes(product.category)) return false;\n    }\n\n    // SKU filter\n    if (conditions.skus && conditions.skus.length > 0) {\n      if (!conditions.skus.includes(product.sku)) return false;\n    }\n\n    // SKU pattern filter\n    if (conditions.skuPatterns && conditions.skuPatterns.length > 0) {\n      const matches = conditions.skuPatterns.some((pattern) =>\n        new RegExp(pattern).test(product.sku)\n      );\n      if (!matches) return false;\n    }\n\n    // Margin conditions\n    if (conditions.marginBelow !== undefined) {\n      if (breakdown.marginPercent >= conditions.marginBelow) return false;\n    }\n    if (conditions.marginAbove !== undefined) {\n      if (breakdown.marginPercent <= conditions.marginAbove) return false;\n    }\n\n    // Stock conditions\n    if (conditions.stockBelow !== undefined) {\n      if (product.stockLevel >= conditions.stockBelow) return false;\n    }\n    if (conditions.stockAbove !== undefined) {\n      if (product.stockLevel <= conditions.stockAbove) return false;\n    }\n\n    // Sales velocity conditions\n    if (conditions.salesVelocityBelow !== undefined) {\n      if (product.salesLast7Days >= conditions.salesVelocityBelow) return false;\n    }\n    if (conditions.salesVelocityAbove !== undefined) {\n      if (product.salesLast7Days <= conditions.salesVelocityAbove) return false;\n    }\n\n    // Price conditions\n    if (conditions.priceBelow !== undefined) {\n      if (product.currentPrice >= conditions.priceBelow) return false;\n    }\n    if (conditions.priceAbove !== undefined) {\n      if (product.currentPrice <= conditions.priceAbove) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Apply a rule's action to calculate new price\n   */\n  private applyRule(\n    rule: PricingRule,\n    product: Product,\n    channel: Channel\n  ): { price: number; reason: string } {\n    const action = rule.action;\n\n    switch (action.type) {\n      case 'set_margin': {\n        // Calculate price to achieve target margin\n        const targetMargin = action.value / 100;\n        const totalCostRate =\n          (channel.commissionPercent +\n            (channel.paymentProcessingPercent || 0) +\n            (channel.defaultAcosPercent || 0)) /\n          100;\n        const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n        // Price = FixedCosts / (1 - totalCostRate - targetMargin)\n        const divisor = 1 - totalCostRate - targetMargin;\n        if (divisor <= 0) {\n          return {\n            price: product.currentPrice,\n            reason: `Cannot achieve ${action.value}% margin - costs too high`,\n          };\n        }\n        const price = fixedCosts / divisor;\n        return {\n          price,\n          reason: `Set to achieve ${action.value}% margin (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_markup': {\n        // Price = Cost \u00D7 Markup multiplier\n        const price = (product.costPrice || 0) * action.value;\n        return {\n          price,\n          reason: `Applied ${action.value}x markup on cost (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_percent': {\n        // Adjust by percentage\n        const price = product.currentPrice * (1 + action.value / 100);\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `${Math.abs(action.value)}% ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_fixed': {\n        // Adjust by fixed amount\n        const price = product.currentPrice + action.value;\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `\u00A3${Math.abs(action.value).toFixed(2)} ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_price': {\n        return {\n          price: action.value,\n          reason: `Set to fixed price \u00A3${action.value.toFixed(2)} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'match_mrp': {\n        return {\n          price: product.mrp,\n          reason: `Set to MRP (rule: ${rule.name})`,\n        };\n      }\n\n      case 'discount_from_mrp': {\n        const price = product.mrp * (1 - action.value / 100);\n        return {\n          price,\n          reason: `${action.value}% discount from MRP (rule: ${rule.name})`,\n        };\n      }\n\n      default:\n        return {\n          price: product.currentPrice,\n          reason: 'Unknown action type',\n        };\n    }\n  }\n\n  /**\n   * Calculate floor price (minimum to achieve minimum margin)\n   */\n  private calculateFloorPrice(product: Product, channel: Channel): number {\n    const targetMargin = this.config.minimumMarginPercent / 100;\n    const totalCostRate =\n      (channel.commissionPercent +\n        (channel.paymentProcessingPercent || 0) +\n        (channel.defaultAcosPercent || 0)) /\n      100;\n    const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n    const divisor = 1 - totalCostRate - targetMargin;\n    if (divisor <= 0) return product.currentPrice;\n\n    return fixedCosts / divisor;\n  }\n\n  /**\n   * Apply rounding rule to price\n   */\n  private applyRounding(price: number, rule: RoundingRule): number {\n    switch (rule) {\n      case 'nearest_99p':\n        return Math.floor(price) + 0.99;\n      case 'nearest_95p':\n        return Math.floor(price) + 0.95;\n      case 'nearest_pound':\n        return Math.round(price);\n      case 'round_down':\n        return Math.floor(price * 100) / 100;\n      case 'round_up':\n        return Math.ceil(price * 100) / 100;\n      case 'none':\n      default:\n        return Math.round(price * 100) / 100;\n    }\n  }\n\n  /**\n   * Generate proposals for all products\n   */\n  generateProposals(products: Product[], batchId: string): PriceProposal[] {\n    const proposals: PriceProposal[] = [];\n\n    for (const product of products) {\n      const result = this.calculatePrice(product);\n\n      // Only create proposal if price changed\n      if (Math.abs(result.priceChange) < 0.01) continue;\n\n      const proposal: PriceProposal = {\n        proposalId: uuid(),\n        sku: product.sku,\n        productTitle: product.title,\n        brand: product.brand,\n        category: product.category,\n        currentPrice: result.currentPrice,\n        proposedPrice: result.proposedPrice,\n        priceChange: result.priceChange,\n        priceChangePercent: result.priceChangePercent,\n        currentMargin: result.currentMargin,\n        proposedMargin: result.proposedMargin,\n        marginChange: result.marginChange,\n        costBreakdown: result.costBreakdown,\n        stockLevel: product.stockLevel,\n        salesLast7Days: product.salesLast7Days,\n        salesLast30Days: product.salesLast30Days,\n        appliedRuleName: result.appliedRule,\n        reason: result.reason,\n        warnings: result.warnings,\n        status: 'pending',\n        createdAt: new Date().toISOString(),\n        batchId,\n        ttl: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60, // 30 days\n      };\n\n      proposals.push(proposal);\n    }\n\n    return proposals;\n  }\n}\n", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport {\n  DynamoDBDocumentClient,\n  GetCommand,\n  PutCommand,\n  QueryCommand,\n  ScanCommand,\n  UpdateCommand,\n  BatchWriteCommand,\n} from '@aws-sdk/lib-dynamodb';\nimport {\n  Product,\n  Channel,\n  PricingRule,\n  PriceProposal,\n  ProposalStatus,\n  ProposalFilters,\n  PaginatedProposals,\n} from '../types';\n\n/**\n * DynamoDB service for all database operations\n */\nexport class DynamoDBService {\n  private docClient: DynamoDBDocumentClient;\n  private productsTable: string;\n  private rulesTable: string;\n  private proposalsTable: string;\n  private channelsTable: string;\n\n  constructor(config: {\n    productsTable: string;\n    rulesTable: string;\n    proposalsTable: string;\n    channelsTable: string;\n  }) {\n    const client = new DynamoDBClient({});\n    this.docClient = DynamoDBDocumentClient.from(client, {\n      marshallOptions: { removeUndefinedValues: true },\n    });\n\n    this.productsTable = config.productsTable;\n    this.rulesTable = config.rulesTable;\n    this.proposalsTable = config.proposalsTable;\n    this.channelsTable = config.channelsTable;\n  }\n\n  // ============ Products ============\n\n  async getProduct(sku: string): Promise<Product | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.productsTable,\n        Key: { sku },\n      })\n    );\n    return (result.Item as Product) || null;\n  }\n\n  async putProduct(product: Product): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.productsTable,\n        Item: { ...product, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllProducts(): Promise<Product[]> {\n    const products: Product[] = [];\n    let lastKey: Record<string, unknown> | undefined;\n\n    do {\n      const result = await this.docClient.send(\n        new ScanCommand({\n          TableName: this.productsTable,\n          ExclusiveStartKey: lastKey,\n        })\n      );\n\n      if (result.Items) {\n        products.push(...(result.Items as Product[]));\n      }\n      lastKey = result.LastEvaluatedKey;\n    } while (lastKey);\n\n    return products;\n  }\n\n  async batchPutProducts(products: Product[]): Promise<void> {\n    const timestamp = new Date().toISOString();\n\n    // DynamoDB batch write limit is 25 items\n    const chunks = this.chunkArray(products, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.productsTable]: chunk.map((product) => ({\n              PutRequest: {\n                Item: { ...product, lastUpdated: timestamp },\n              },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProductsByBrand(brand: string): Promise<Product[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.productsTable,\n        IndexName: 'by-brand',\n        KeyConditionExpression: 'brand = :brand',\n        ExpressionAttributeValues: { ':brand': brand },\n      })\n    );\n    return (result.Items as Product[]) || [];\n  }\n\n  // ============ Pricing Rules ============\n\n  async getRule(ruleId: string): Promise<PricingRule | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n    return (result.Item as PricingRule) || null;\n  }\n\n  async putRule(rule: PricingRule): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.rulesTable,\n        Item: { ...rule, updatedAt: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllRules(): Promise<PricingRule[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.rulesTable,\n      })\n    );\n    return ((result.Items as PricingRule[]) || []).sort((a, b) => a.priority - b.priority);\n  }\n\n  async deleteRule(ruleId: string): Promise<void> {\n    const { DeleteCommand } = await import('@aws-sdk/lib-dynamodb');\n    await this.docClient.send(\n      new DeleteCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n  }\n\n  // ============ Proposals ============\n\n  async getProposal(proposalId: string): Promise<PriceProposal | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n      })\n    );\n    return (result.Item as PriceProposal) || null;\n  }\n\n  async putProposal(proposal: PriceProposal): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.proposalsTable,\n        Item: proposal,\n      })\n    );\n  }\n\n  async batchPutProposals(proposals: PriceProposal[]): Promise<void> {\n    const chunks = this.chunkArray(proposals, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.proposalsTable]: chunk.map((proposal) => ({\n              PutRequest: { Item: proposal },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProposalsByStatus(status: ProposalStatus): Promise<PriceProposal[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.proposalsTable,\n        IndexName: 'by-status',\n        KeyConditionExpression: '#status = :status',\n        ExpressionAttributeNames: { '#status': 'status' },\n        ExpressionAttributeValues: { ':status': status },\n        ScanIndexForward: false, // Most recent first\n      })\n    );\n    return (result.Items as PriceProposal[]) || [];\n  }\n\n  async queryProposals(\n    filters: ProposalFilters,\n    page: number = 1,\n    pageSize: number = 50\n  ): Promise<PaginatedProposals> {\n    // Build filter expression\n    const filterExpressions: string[] = [];\n    const expressionAttributeNames: Record<string, string> = {};\n    const expressionAttributeValues: Record<string, unknown> = {};\n\n    if (filters.status) {\n      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];\n      if (statuses.length === 1) {\n        filterExpressions.push('#status = :status');\n        expressionAttributeNames['#status'] = 'status';\n        expressionAttributeValues[':status'] = statuses[0];\n      }\n    }\n\n    if (filters.brand) {\n      filterExpressions.push('brand = :brand');\n      expressionAttributeValues[':brand'] = filters.brand;\n    }\n\n    if (filters.batchId) {\n      filterExpressions.push('batchId = :batchId');\n      expressionAttributeValues[':batchId'] = filters.batchId;\n    }\n\n    if (filters.hasWarnings) {\n      filterExpressions.push('size(warnings) > :zero');\n      expressionAttributeValues[':zero'] = 0;\n    }\n\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.proposalsTable,\n        FilterExpression: filterExpressions.length > 0 ? filterExpressions.join(' AND ') : undefined,\n        ExpressionAttributeNames:\n          Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,\n        ExpressionAttributeValues:\n          Object.keys(expressionAttributeValues).length > 0 ? expressionAttributeValues : undefined,\n      })\n    );\n\n    let items = (result.Items as PriceProposal[]) || [];\n\n    // Apply search filter (client-side for simplicity)\n    if (filters.searchTerm) {\n      const term = filters.searchTerm.toLowerCase();\n      items = items.filter(\n        (p) =>\n          p.sku.toLowerCase().includes(term) ||\n          p.productTitle.toLowerCase().includes(term)\n      );\n    }\n\n    // Sort by createdAt descending\n    items.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Paginate\n    const totalCount = items.length;\n    const startIndex = (page - 1) * pageSize;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n\n    return {\n      items: paginatedItems,\n      totalCount,\n      page,\n      pageSize,\n      hasMore: startIndex + pageSize < totalCount,\n    };\n  }\n\n  async updateProposalStatus(\n    proposalId: string,\n    status: ProposalStatus,\n    reviewedBy: string,\n    notes?: string,\n    approvedPrice?: number\n  ): Promise<void> {\n    const updateExpressions: string[] = [\n      '#status = :status',\n      'reviewedAt = :reviewedAt',\n      'reviewedBy = :reviewedBy',\n    ];\n    const expressionAttributeNames: Record<string, string> = { '#status': 'status' };\n    const expressionAttributeValues: Record<string, unknown> = {\n      ':status': status,\n      ':reviewedAt': new Date().toISOString(),\n      ':reviewedBy': reviewedBy,\n    };\n\n    if (notes) {\n      updateExpressions.push('reviewNotes = :notes');\n      expressionAttributeValues[':notes'] = notes;\n    }\n\n    if (approvedPrice !== undefined) {\n      updateExpressions.push('approvedPrice = :approvedPrice');\n      expressionAttributeValues[':approvedPrice'] = approvedPrice;\n    }\n\n    await this.docClient.send(\n      new UpdateCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n        UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n        ExpressionAttributeNames: expressionAttributeNames,\n        ExpressionAttributeValues: expressionAttributeValues,\n      })\n    );\n  }\n\n  // ============ Channels ============\n\n  async getChannel(channelId: string): Promise<Channel | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.channelsTable,\n        Key: { channelId },\n      })\n    );\n    return (result.Item as Channel) || null;\n  }\n\n  async putChannel(channel: Channel): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.channelsTable,\n        Item: { ...channel, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllChannels(): Promise<Channel[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.channelsTable,\n      })\n    );\n    return (result.Items as Channel[]) || [];\n  }\n\n  // ============ Utilities ============\n\n  private chunkArray<T>(array: T[], size: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n}\n\n/**\n * Create DynamoDB service from environment variables\n */\nexport function createDynamoDBService(): DynamoDBService {\n  return new DynamoDBService({\n    productsTable: process.env.PRODUCTS_TABLE || 'repricing-products',\n    rulesTable: process.env.PRICING_RULES_TABLE || 'repricing-rules',\n    proposalsTable: process.env.PRICE_PROPOSALS_TABLE || 'repricing-proposals',\n    channelsTable: process.env.CHANNEL_CONFIG_TABLE || 'repricing-channels',\n  });\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "handler", "__toCommonJS", "import_googleapis", "GoogleSheetsService", "credentials", "spreadsheetId", "auth", "sheetName", "rows", "headers", "row", "getValue", "index", "getNumber", "val", "sheetProduct", "prices", "p", "currentPrice", "s", "createGoogleSheetsService", "secretArn", "SecretsManagerClient", "GetSecretValueCommand", "response", "secret", "ChannelEngineService", "config", "endpoint", "method", "body", "queryParams", "params", "key", "value", "url", "response", "errorText", "products", "page", "pageSize", "hasMore", "product", "fromDate", "toDate", "salesMap", "fromStr", "toStr", "order", "line", "existing", "now", "sevenDaysAgo", "thirtyDaysAgo", "sales7Days", "sales30Days", "allSkus", "sku", "updates", "errors", "i", "chunk", "payload", "u", "error", "createChannelEngineService", "secretArn", "SecretsManagerClient", "GetSecretValueCommand", "secret", "import_uuid", "import_client_dynamodb", "import_lib_dynamodb", "DynamoDBService", "config", "client", "sku", "product", "products", "lastKey", "result", "timestamp", "chunks", "chunk", "brand", "ruleId", "rule", "a", "b", "DeleteCommand", "proposalId", "proposal", "proposals", "status", "filters", "page", "pageSize", "filterExpressions", "expressionAttributeNames", "expressionAttributeValues", "statuses", "items", "term", "p", "totalCount", "startIndex", "reviewedBy", "notes", "approvedPrice", "updateExpressions", "channelId", "channel", "array", "size", "i", "createDynamoDBService", "handler", "event", "context", "db", "createDynamoDBService", "ceProducts", "fetchFromChannelEngine", "sheetData", "fetchFromGoogleSheets", "existingProducts", "existingMap", "p", "products", "buildProducts", "enrichedCount", "withCostCount", "summary", "error", "secretArn", "ceService", "createChannelEngineService", "salesMetrics", "salesMap", "s", "sheetProducts", "createGoogleSheetsService", "map", "product", "ceData", "timestamp", "ceProduct", "sku", "existing", "sheetProduct", "sales", "channelPrices", "sheetPrices", "currentPrice"]
}
