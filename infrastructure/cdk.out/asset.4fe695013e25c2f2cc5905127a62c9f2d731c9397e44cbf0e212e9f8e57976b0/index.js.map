{
  "version": 3,
  "sources": ["../../../packages/lambdas/data-sync/src/index.ts", "../../../packages/core/src/services/google-sheets.ts", "../../../packages/core/src/services/channel-engine.ts", "../../../packages/core/src/services/pricing-engine.ts", "../../../packages/core/src/services/dynamodb.ts"],
  "sourcesContent": ["import { ScheduledEvent, Context } from 'aws-lambda';\nimport {\n  createGoogleSheetsService,\n  createChannelEngineService,\n  createDynamoDBService,\n  Product,\n  ChannelEngineProduct,\n  GoogleSheetProduct,\n} from '@repricing/core';\n\n/**\n * Data Sync Lambda\n * Runs weekly to pull data from ChannelEngine (source of truth) and enrich from Google Sheets\n *\n * Data Flow:\n * 1. ChannelEngine \u2192 Primary source: active products, stock, current CE price\n * 2. Products are saved to DynamoDB incrementally as they are fetched (not at the end)\n * 3. Cost data is NOT synced here - it's matched at price calculation time from CSV uploads\n */\nexport async function handler(event: ScheduledEvent, context: Context): Promise<void> {\n  console.log('Starting data sync', { event, requestId: context.awsRequestId });\n\n  const db = createDynamoDBService();\n  let totalSaved = 0;\n  let totalProducts = 0;\n\n  try {\n    // 1. Get existing products from DB (to preserve cost data)\n    console.log('[DB] Loading existing products to preserve cost data...');\n    const existingProducts = await db.getAllProducts();\n    const existingMap = new Map(existingProducts.map((p) => [p.sku, p]));\n    console.log(`[DB] Found ${existingProducts.length} existing products`);\n\n    // 2. Fetch products from ChannelEngine and SAVE EACH BATCH IMMEDIATELY\n    console.log('[CE] Starting incremental fetch and save...');\n\n    const secretArn = process.env.CHANNEL_ENGINE_SECRET_ARN;\n    if (!secretArn) {\n      throw new Error('CHANNEL_ENGINE_SECRET_ARN not configured');\n    }\n\n    const ceService = await createChannelEngineService(secretArn);\n\n    await ceService.fetchProducts(async (batchProducts, page, total) => {\n      // Transform and save this batch immediately\n      const timestamp = new Date().toISOString();\n      const productsToSave: Product[] = batchProducts.map((ceProduct) => {\n        const sku = ceProduct.merchantProductNo;\n        const existing = existingMap.get(sku);\n\n        return {\n          sku,\n          title: ceProduct.name || sku,\n          brand: ceProduct.brand || 'Unknown',\n          category: ceProduct.categoryTrail || 'Uncategorized',\n          mrp: existing?.mrp || 0,\n          currentPrice: ceProduct.price,\n          costPrice: existing?.costPrice || 0,\n          deliveryCost: existing?.deliveryCost || 0,\n          stockLevel: ceProduct.stock,\n          stockLastUpdated: timestamp,\n          salesLast7Days: existing?.salesLast7Days || 0,\n          salesLast30Days: existing?.salesLast30Days || 0,\n          lastUpdated: timestamp,\n          lastSyncedFromChannelEngine: timestamp,\n        };\n      });\n\n      // Save to DynamoDB\n      await db.batchPutProducts(productsToSave);\n      totalSaved += productsToSave.length;\n      totalProducts = total;\n      console.log(`[DB] Saved batch ${page}: ${productsToSave.length} products (${totalSaved}/${total} total saved)`);\n    });\n\n    console.log(`[DONE] Data sync complete: ${totalSaved} products saved to DynamoDB`);\n\n  } catch (error) {\n    console.error(`[ERROR] Data sync failed after saving ${totalSaved} products:`, error);\n    throw error;\n  }\n}\n\n/**\n * Fetch products and sales data from ChannelEngine (PRIMARY SOURCE)\n */\nasync function fetchFromChannelEngine(): Promise<{\n  products: ChannelEngineProduct[];\n  salesMap: Map<string, { salesLast7Days: number; salesLast30Days: number }>;\n}> {\n  const secretArn = process.env.CHANNEL_ENGINE_SECRET_ARN;\n  if (!secretArn) {\n    throw new Error('CHANNEL_ENGINE_SECRET_ARN not configured - ChannelEngine is required as primary data source');\n  }\n\n  console.log('[CE] Initializing ChannelEngine service...');\n  const ceService = await createChannelEngineService(secretArn);\n\n  // Fetch all products with full details\n  console.log('[CE] Fetching products...');\n  const products = await ceService.fetchProducts();\n  console.log(`[CE] Fetched ${products.length} products`);\n\n  // Skip sales fetch for now - it takes too long and can be done separately\n  // TODO: Make sales fetch optional or run in separate Lambda\n  console.log('[CE] Skipping sales metrics fetch (performance optimization)');\n  const salesMap = new Map<string, { salesLast7Days: number; salesLast30Days: number }>();\n\n  return { products, salesMap };\n}\n\n/**\n * Fetch enrichment data from Google Sheets (MRP, channel pricing, discounts)\n * Returns a Map keyed by SKU for easy lookup\n */\nasync function fetchFromGoogleSheets(): Promise<Map<string, GoogleSheetProduct>> {\n  const secretArn = process.env.GOOGLE_SHEETS_SECRET_ARN;\n  if (!secretArn) {\n    console.warn('GOOGLE_SHEETS_SECRET_ARN not configured - skipping Sheets enrichment');\n    return new Map();\n  }\n\n  try {\n    const sheetsService = await createGoogleSheetsService(secretArn);\n    const sheetProducts = await sheetsService.fetchProducts();\n\n    // Create lookup map by SKU\n    const map = new Map<string, GoogleSheetProduct>();\n    for (const product of sheetProducts) {\n      if (product.productSku) {\n        map.set(product.productSku, product);\n      }\n    }\n    return map;\n  } catch (error) {\n    console.error('Google Sheets fetch failed:', error);\n    return new Map();\n  }\n}\n\n/**\n * Build Product records from ChannelEngine (base) + Google Sheets (enrichment) + existing DB (costs)\n */\nfunction buildProducts(\n  ceData: {\n    products: ChannelEngineProduct[];\n    salesMap: Map<string, { salesLast7Days: number; salesLast30Days: number }>;\n  },\n  sheetData: Map<string, GoogleSheetProduct>,\n  existingProducts: Map<string, Product>\n): Product[] {\n  const timestamp = new Date().toISOString();\n  const products: Product[] = [];\n\n  // Iterate over ChannelEngine products (source of truth for active products)\n  for (const ceProduct of ceData.products) {\n    const sku = ceProduct.merchantProductNo;\n    const existing = existingProducts.get(sku);\n    const sheetProduct = sheetData.get(sku);\n    const sales = ceData.salesMap.get(sku);\n\n    // Determine current price: prefer sheet pricing, fallback to CE price\n    const channelPrices = sheetProduct ? {\n      amazon: sheetProduct.amazonPricing || undefined,\n      ebay: sheetProduct.ebayPricing || undefined,\n      bandq: sheetProduct.bandqPricing || undefined,\n      manomano: sheetProduct.manoManoPricing || undefined,\n      shopify: sheetProduct.shopifyPricing || undefined,\n    } : undefined;\n\n    // Use the first non-zero channel price or CE price as current price\n    const sheetPrices = [\n      sheetProduct?.amazonPricing,\n      sheetProduct?.ebayPricing,\n      sheetProduct?.bandqPricing,\n      sheetProduct?.manoManoPricing,\n      sheetProduct?.shopifyPricing,\n    ].filter((p): p is number => p !== undefined && p > 0);\n\n    const currentPrice = sheetPrices.length > 0 ? sheetPrices[0] : ceProduct.price;\n\n    const product: Product = {\n      // Core identifiers from ChannelEngine\n      sku,\n      title: ceProduct.name || sku,\n      brand: sheetProduct?.brandName || ceProduct.brand || 'Unknown',\n      category: ceProduct.categoryTrail || 'Uncategorized',\n\n      // Enrichment from Google Sheets\n      balterleySku: sheetProduct?.balterleySku || existing?.balterleySku,\n      familyVariants: sheetProduct?.familyVariants || existing?.familyVariants,\n      mrp: sheetProduct?.mrp || existing?.mrp || 0,\n      currentPrice,\n      channelPrices,\n\n      // Discount info from Sheets\n      discountPrice: sheetProduct?.discountPrice,\n      discountStartDate: sheetProduct?.discountStartDate,\n      discountEndDate: sheetProduct?.discountEndDate,\n\n      // Cost data preserved from existing DB (updated via CSV import)\n      costPrice: existing?.costPrice || 0,\n      deliveryCost: existing?.deliveryCost || 0,\n\n      // Stock from ChannelEngine\n      stockLevel: ceProduct.stock,\n      stockLastUpdated: timestamp,\n\n      // Sales from ChannelEngine\n      salesLast7Days: sales?.salesLast7Days || 0,\n      salesLast30Days: sales?.salesLast30Days || 0,\n      salesLastUpdated: sales ? timestamp : existing?.salesLastUpdated,\n\n      // Timestamps\n      lastUpdated: timestamp,\n      lastSyncedFromSheet: sheetProduct ? timestamp : existing?.lastSyncedFromSheet,\n      lastSyncedFromChannelEngine: timestamp,\n    };\n\n    products.push(product);\n  }\n\n  return products;\n}\n", "import { google, sheets_v4 } from 'googleapis';\nimport { GoogleSheetProduct, Product } from '../types';\n\n/**\n * Google Sheets service for reading pricing data\n */\nexport class GoogleSheetsService {\n  private sheets: sheets_v4.Sheets;\n  private spreadsheetId: string;\n\n  constructor(credentials: object, spreadsheetId: string) {\n    const auth = new google.auth.GoogleAuth({\n      credentials,\n      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],\n    });\n\n    this.sheets = google.sheets({ version: 'v4', auth });\n    this.spreadsheetId = spreadsheetId;\n  }\n\n  /**\n   * Fetch all products from the pricing sheet\n   */\n  async fetchProducts(sheetName: string = 'Sheet1'): Promise<GoogleSheetProduct[]> {\n    const response = await this.sheets.spreadsheets.values.get({\n      spreadsheetId: this.spreadsheetId,\n      range: `${sheetName}!A:O`, // Columns A through O based on sheet structure\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    // First row is headers\n    const headers = rows[0];\n    const dataRows = rows.slice(1);\n\n    return dataRows\n      .filter((row) => row[1]) // Must have SKU\n      .map((row) => this.parseRow(row, headers));\n  }\n\n  /**\n   * Parse a single row into a GoogleSheetProduct\n   */\n  private parseRow(row: string[], headers: string[]): GoogleSheetProduct {\n    const getValue = (index: number): string => row[index]?.trim() || '';\n    const getNumber = (index: number): number => {\n      const val = row[index]?.replace(/[\u00A3$,]/g, '').trim();\n      return parseFloat(val) || 0;\n    };\n\n    // Map columns based on known sheet structure\n    // Columns: Brand Name, Product SKU, Balterley SKU, Family Variants, MRP,\n    //          B&Q Pricing, Amazon Pricing, eBay Pricing, ManoMano Pricing, Shopify Pricing,\n    //          (empty), discount-start-date, discount-end-date, discount-price\n    return {\n      brandName: getValue(0),\n      productSku: getValue(1),\n      balterleySku: getValue(2),\n      familyVariants: getValue(3),\n      mrp: getNumber(4),\n      bandqPricing: getNumber(5),\n      amazonPricing: getNumber(6),\n      ebayPricing: getNumber(7),\n      manoManoPricing: getNumber(8),\n      shopifyPricing: getNumber(9),\n      discountStartDate: getValue(11) || undefined,\n      discountEndDate: getValue(12) || undefined,\n      discountPrice: getNumber(13) || undefined,\n    };\n  }\n\n  /**\n   * Transform Google Sheet product to internal Product format\n   * Note: Cost and delivery data must be merged from separate sources\n   */\n  static toProduct(sheetProduct: GoogleSheetProduct): Partial<Product> {\n    // For unified pricing, use Amazon price as the base (most common)\n    // or calculate average of non-zero prices\n    const prices = [\n      sheetProduct.amazonPricing,\n      sheetProduct.ebayPricing,\n      sheetProduct.bandqPricing,\n      sheetProduct.manoManoPricing,\n      sheetProduct.shopifyPricing,\n    ].filter((p) => p > 0);\n\n    const currentPrice = prices.length > 0 ? prices[0] : sheetProduct.mrp;\n\n    return {\n      sku: sheetProduct.productSku,\n      balterleySku: sheetProduct.balterleySku || undefined,\n      title: sheetProduct.productSku, // Will be enriched from ChannelEngine\n      brand: sheetProduct.brandName,\n      familyVariants: sheetProduct.familyVariants || undefined,\n      mrp: sheetProduct.mrp,\n      currentPrice,\n      channelPrices: {\n        amazon: sheetProduct.amazonPricing || undefined,\n        ebay: sheetProduct.ebayPricing || undefined,\n        bandq: sheetProduct.bandqPricing || undefined,\n        manomano: sheetProduct.manoManoPricing || undefined,\n        shopify: sheetProduct.shopifyPricing || undefined,\n      },\n      discountPrice: sheetProduct.discountPrice || undefined,\n      discountStartDate: sheetProduct.discountStartDate || undefined,\n      discountEndDate: sheetProduct.discountEndDate || undefined,\n      lastSyncedFromSheet: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Get sheet metadata to find available sheets\n   */\n  async getSheetNames(): Promise<string[]> {\n    const response = await this.sheets.spreadsheets.get({\n      spreadsheetId: this.spreadsheetId,\n    });\n\n    return response.data.sheets?.map((s) => s.properties?.title || '') || [];\n  }\n}\n\n/**\n * Factory function to create GoogleSheetsService from AWS Secrets\n */\nexport async function createGoogleSheetsService(\n  secretArn: string\n): Promise<GoogleSheetsService> {\n  // Import dynamically to avoid bundling issues\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('Google Sheets secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n  const credentials = JSON.parse(secret.credentials);\n\n  return new GoogleSheetsService(credentials, secret.spreadsheetId);\n}\n", "import { ChannelEngineProduct, ChannelEngineSalesData, ChannelEngineOrder, ChannelEngineOrderLine } from '../types';\n\n/**\n * ChannelEngine API configuration\n */\ninterface ChannelEngineConfig {\n  apiKey: string;\n  tenantId: string;\n  baseUrl?: string;\n}\n\n/**\n * ChannelEngine API response wrapper\n */\ninterface ChannelEngineResponse<T> {\n  Content: T;\n  StatusCode: number;\n  Success: boolean;\n  Message?: string;\n  TotalCount?: number;\n}\n\n/**\n * ChannelEngine product from API\n */\ninterface CEProduct {\n  MerchantProductNo: string;\n  Name: string;\n  Description?: string;\n  Brand?: string;\n  Stock: number;\n  Price: number;\n  CategoryTrail?: string;\n  Ean?: string;\n}\n\n/**\n * ChannelEngine order line item\n */\ninterface CEOrderLine {\n  MerchantProductNo: string;\n  Quantity: number;\n  UnitPriceInclVat: number;\n  OrderDateUtc: string;\n}\n\n/**\n * ChannelEngine service for inventory and sales data\n */\nexport class ChannelEngineService {\n  private apiKey: string;\n  private tenantId: string;\n  private baseUrl: string;\n\n  constructor(config: ChannelEngineConfig) {\n    this.apiKey = config.apiKey;\n    this.tenantId = config.tenantId;\n    this.baseUrl = config.baseUrl || 'https://api.channelengine.net/api/v2';\n  }\n\n  /**\n   * Make authenticated request to ChannelEngine API\n   * Authentication is via apikey query parameter (not header)\n   */\n  private async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST' | 'PUT' = 'GET',\n    body?: unknown,\n    queryParams: Record<string, string | number> = {}\n  ): Promise<ChannelEngineResponse<T>> {\n    // Add API key to query parameters (ChannelEngine's authentication method)\n    const params = new URLSearchParams();\n    params.set('apikey', this.apiKey);\n    for (const [key, value] of Object.entries(queryParams)) {\n      params.set(key, String(value));\n    }\n\n    const url = `${this.baseUrl}${endpoint}?${params.toString()}`;\n\n    const response = await fetch(url, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`ChannelEngine API error: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json() as Promise<ChannelEngineResponse<T>>;\n  }\n\n  /**\n   * Fetch all products with full details (stock, price, name, brand, etc.)\n   * Calls onBatch callback after each page to allow incremental processing/saving\n   */\n  async fetchProducts(onBatch?: (products: ChannelEngineProduct[], page: number, total: number) => Promise<void>): Promise<ChannelEngineProduct[]> {\n    const allProducts: ChannelEngineProduct[] = [];\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n    let totalCount = 0;\n\n    console.log(`[CE] Starting product fetch from ${this.baseUrl}/products`);\n\n    while (hasMore) {\n      console.log(`[CE] Fetching page ${page}...`);\n\n      try {\n        const response = await this.request<CEProduct[]>(\n          '/products',\n          'GET',\n          undefined,\n          { page, pageSize }\n        );\n\n        totalCount = response.TotalCount || totalCount;\n\n        if (response.Content && response.Content.length > 0) {\n          const batchProducts: ChannelEngineProduct[] = [];\n\n          for (const product of response.Content) {\n            batchProducts.push({\n              merchantProductNo: product.MerchantProductNo,\n              name: product.Name,\n              description: product.Description,\n              brand: product.Brand,\n              ean: product.Ean,\n              stock: product.Stock,\n              price: product.Price,\n              categoryTrail: product.CategoryTrail,\n            });\n          }\n\n          allProducts.push(...batchProducts);\n          console.log(`[CE] Page ${page}: Got ${batchProducts.length} products (${allProducts.length}/${totalCount})`);\n\n          // Call batch callback to save immediately\n          if (onBatch) {\n            await onBatch(batchProducts, page, totalCount);\n          }\n\n          page++;\n          hasMore = response.Content.length === pageSize;\n        } else {\n          console.log(`[CE] Page ${page}: No more products`);\n          hasMore = false;\n        }\n      } catch (error) {\n        console.error(`[CE] Error fetching page ${page}:`, error);\n        throw error;\n      }\n    }\n\n    console.log(`[CE] Completed: Fetched ${allProducts.length} total products`);\n    return allProducts;\n  }\n\n  /**\n   * Fetch sales data for products over a date range\n   */\n  async fetchSalesData(\n    fromDate: Date,\n    toDate: Date\n  ): Promise<Map<string, { quantity: number; revenue: number }>> {\n    const salesMap = new Map<string, { quantity: number; revenue: number }>();\n\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n\n    const fromStr = fromDate.toISOString();\n    const toStr = toDate.toISOString();\n\n    while (hasMore) {\n      const response = await this.request<{ Lines: CEOrderLine[] }[]>(\n        '/orders',\n        'GET',\n        undefined,\n        { fromDate: fromStr, toDate: toStr, page, pageSize }\n      );\n\n      if (response.Content && response.Content.length > 0) {\n        for (const order of response.Content) {\n          if (order.Lines) {\n            for (const line of order.Lines) {\n              const existing = salesMap.get(line.MerchantProductNo) || {\n                quantity: 0,\n                revenue: 0,\n              };\n              existing.quantity += line.Quantity;\n              existing.revenue += line.UnitPriceInclVat * line.Quantity;\n              salesMap.set(line.MerchantProductNo, existing);\n            }\n          }\n        }\n        page++;\n        hasMore = response.Content.length === pageSize;\n      } else {\n        hasMore = false;\n      }\n    }\n\n    return salesMap;\n  }\n\n  /**\n   * Calculate sales metrics for last 7 and 30 days\n   */\n  async fetchSalesMetrics(): Promise<ChannelEngineSalesData[]> {\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    const [sales7Days, sales30Days] = await Promise.all([\n      this.fetchSalesData(sevenDaysAgo, now),\n      this.fetchSalesData(thirtyDaysAgo, now),\n    ]);\n\n    // Combine all SKUs from both periods\n    const allSkus = new Set([...sales7Days.keys(), ...sales30Days.keys()]);\n\n    return Array.from(allSkus).map((sku) => ({\n      merchantProductNo: sku,\n      salesLast7Days: sales7Days.get(sku)?.quantity || 0,\n      salesLast30Days: sales30Days.get(sku)?.quantity || 0,\n    }));\n  }\n\n  /**\n   * Fetch all orders from a given date with incremental batch processing\n   * @param fromDate Start date to fetch orders from\n   * @param onBatch Callback called after each page for incremental saving\n   */\n  async fetchOrders(\n    fromDate: Date,\n    onBatch?: (orders: ChannelEngineOrder[], page: number, total: number) => Promise<void>\n  ): Promise<ChannelEngineOrder[]> {\n    const allOrders: ChannelEngineOrder[] = [];\n    let page = 1;\n    const pageSize = 100;\n    let hasMore = true;\n    let totalCount = 0;\n\n    const fromStr = fromDate.toISOString();\n    console.log(`[CE] Starting order fetch from ${fromStr}`);\n\n    while (hasMore) {\n      console.log(`[CE] Fetching orders page ${page}...`);\n\n      try {\n        const response = await this.request<ChannelEngineOrder[]>(\n          '/orders',\n          'GET',\n          undefined,\n          { fromDate: fromStr, page, pageSize }\n        );\n\n        totalCount = response.TotalCount || totalCount;\n\n        if (response.Content && response.Content.length > 0) {\n          allOrders.push(...response.Content);\n          console.log(`[CE] Page ${page}: Got ${response.Content.length} orders (${allOrders.length}/${totalCount})`);\n\n          // Call batch callback to save immediately\n          if (onBatch) {\n            await onBatch(response.Content, page, totalCount);\n          }\n\n          page++;\n          hasMore = response.Content.length === pageSize;\n        } else {\n          console.log(`[CE] Page ${page}: No more orders`);\n          hasMore = false;\n        }\n      } catch (error) {\n        console.error(`[CE] Error fetching orders page ${page}:`, error);\n        throw error;\n      }\n    }\n\n    console.log(`[CE] Completed: Fetched ${allOrders.length} total orders`);\n    return allOrders;\n  }\n\n  /**\n   * Update product prices in ChannelEngine\n   */\n  async updatePrices(\n    updates: Array<{ merchantProductNo: string; price: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n\n    // ChannelEngine API typically accepts batch updates\n    // Update in chunks of 100\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Price: u.price,\n        }));\n\n        const response = await this.request<unknown>(\n          '/products/bulk',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Update stock levels in ChannelEngine\n   */\n  async updateStock(\n    updates: Array<{ merchantProductNo: string; stock: number }>\n  ): Promise<{ success: boolean; errors: string[] }> {\n    const errors: string[] = [];\n    const chunkSize = 100;\n\n    for (let i = 0; i < updates.length; i += chunkSize) {\n      const chunk = updates.slice(i, i + chunkSize);\n\n      try {\n        const payload = chunk.map((u) => ({\n          MerchantProductNo: u.merchantProductNo,\n          Stock: u.stock,\n        }));\n\n        const response = await this.request<unknown>(\n          '/offer/stock',\n          'PUT',\n          payload\n        );\n\n        if (!response.Success) {\n          errors.push(`Batch ${i / chunkSize + 1}: ${response.Message}`);\n        }\n      } catch (error) {\n        errors.push(\n          `Batch ${i / chunkSize + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n/**\n * Factory function to create ChannelEngineService from AWS Secrets\n */\nexport async function createChannelEngineService(\n  secretArn: string\n): Promise<ChannelEngineService> {\n  const { SecretsManagerClient, GetSecretValueCommand } = await import(\n    '@aws-sdk/client-secrets-manager'\n  );\n\n  const client = new SecretsManagerClient({});\n  const response = await client.send(\n    new GetSecretValueCommand({ SecretId: secretArn })\n  );\n\n  if (!response.SecretString) {\n    throw new Error('ChannelEngine secret not found');\n  }\n\n  const secret = JSON.parse(response.SecretString);\n\n  return new ChannelEngineService({\n    apiKey: secret.apiKey,\n    tenantId: secret.tenantId,\n    baseUrl: secret.baseUrl,\n  });\n}\n", "import {\n  Product,\n  Channel,\n  PricingRule,\n  PricingConfig,\n  PriceCalculationResult,\n  CostBreakdown,\n  calculateCostBreakdown,\n  DEFAULT_PRICING_CONFIG,\n  RoundingRule,\n  PriceProposal,\n} from '../types';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Pricing engine - applies rules to calculate optimal prices\n */\nexport class PricingEngine {\n  private config: PricingConfig;\n  private rules: PricingRule[];\n  private channels: Map<string, Channel>;\n\n  constructor(\n    config: PricingConfig = DEFAULT_PRICING_CONFIG,\n    rules: PricingRule[] = [],\n    channels: Channel[] = []\n  ) {\n    this.config = config;\n    this.rules = rules.sort((a, b) => a.priority - b.priority);\n    this.channels = new Map(channels.map((c) => [c.channelId, c]));\n  }\n\n  /**\n   * Calculate proposed price for a product\n   */\n  calculatePrice(product: Product, channelId: string = 'amazon'): PriceCalculationResult {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not configured`);\n    }\n\n    const warnings: string[] = [];\n\n    // Check if product has required cost data\n    if (!product.costPrice || product.costPrice <= 0) {\n      warnings.push('Missing cost price - cannot calculate accurate margin');\n    }\n\n    // Calculate current margin\n    const currentBreakdown = this.calculateCostBreakdown(product, product.currentPrice, channel);\n\n    // Find applicable rule\n    const applicableRule = this.findApplicableRule(product, currentBreakdown);\n\n    // Calculate proposed price\n    let proposedPrice = product.currentPrice;\n    let reason = 'No rule applied - price unchanged';\n\n    if (applicableRule) {\n      const result = this.applyRule(applicableRule, product, channel);\n      proposedPrice = result.price;\n      reason = result.reason;\n    }\n\n    // Apply rounding\n    proposedPrice = this.applyRounding(proposedPrice, this.config.defaultRoundingRule);\n\n    // Enforce floor price (minimum margin)\n    const floorPrice = this.calculateFloorPrice(product, channel);\n    let atFloorPrice = false;\n    if (proposedPrice < floorPrice) {\n      proposedPrice = this.applyRounding(floorPrice, this.config.defaultRoundingRule);\n      warnings.push(`Price raised to floor (${this.config.minimumMarginPercent}% minimum margin)`);\n      atFloorPrice = true;\n    }\n\n    // Enforce ceiling price (MRP or max discount)\n    const ceilingPrice = product.mrp;\n    let atCeilingPrice = false;\n    if (proposedPrice > ceilingPrice) {\n      proposedPrice = ceilingPrice;\n      warnings.push('Price capped at MRP');\n      atCeilingPrice = true;\n    }\n\n    // Calculate final breakdown\n    const proposedBreakdown = this.calculateCostBreakdown(product, proposedPrice, channel);\n\n    // Check if below minimum margin\n    const belowMinimumMargin = proposedBreakdown.marginPercent < this.config.minimumMarginPercent;\n    if (belowMinimumMargin && !atFloorPrice) {\n      warnings.push(\n        `Margin (${proposedBreakdown.marginPercent.toFixed(1)}%) below minimum (${this.config.minimumMarginPercent}%)`\n      );\n    }\n\n    return {\n      sku: product.sku,\n      currentPrice: product.currentPrice,\n      proposedPrice,\n      priceChange: proposedPrice - product.currentPrice,\n      priceChangePercent:\n        product.currentPrice > 0\n          ? ((proposedPrice - product.currentPrice) / product.currentPrice) * 100\n          : 0,\n      currentMargin: currentBreakdown.marginPercent,\n      proposedMargin: proposedBreakdown.marginPercent,\n      marginChange: proposedBreakdown.marginPercent - currentBreakdown.marginPercent,\n      currentProfit: currentBreakdown.netProfit,\n      proposedProfit: proposedBreakdown.netProfit,\n      costBreakdown: proposedBreakdown,\n      appliedRule: applicableRule?.name,\n      reason,\n      warnings,\n      belowMinimumMargin,\n      atFloorPrice,\n      atCeilingPrice,\n    };\n  }\n\n  /**\n   * Calculate cost breakdown for a price\n   */\n  private calculateCostBreakdown(\n    product: Product,\n    price: number,\n    channel: Channel\n  ): CostBreakdown {\n    const advertisingPercent = channel.includeAdvertisingInMargin\n      ? channel.defaultAcosPercent || 0\n      : 0;\n\n    return calculateCostBreakdown(\n      price,\n      product.costPrice || 0,\n      product.deliveryCost || 0,\n      channel.commissionPercent,\n      channel.fixedFee || 0,\n      channel.paymentProcessingPercent || 0,\n      advertisingPercent,\n      channel.vatPercent,\n      channel.pricesIncludeVat\n    );\n  }\n\n  /**\n   * Find the first rule that applies to this product\n   */\n  private findApplicableRule(\n    product: Product,\n    currentBreakdown: CostBreakdown\n  ): PricingRule | undefined {\n    for (const rule of this.rules) {\n      if (!rule.isActive) continue;\n      if (this.ruleMatches(rule, product, currentBreakdown)) {\n        return rule;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if a rule's conditions match the product\n   */\n  private ruleMatches(\n    rule: PricingRule,\n    product: Product,\n    breakdown: CostBreakdown\n  ): boolean {\n    const conditions = rule.conditions;\n\n    // Brand filter\n    if (conditions.brands && conditions.brands.length > 0) {\n      if (!conditions.brands.includes(product.brand)) return false;\n    }\n\n    // Category filter\n    if (conditions.categories && conditions.categories.length > 0) {\n      if (!product.category || !conditions.categories.includes(product.category)) return false;\n    }\n\n    // SKU filter\n    if (conditions.skus && conditions.skus.length > 0) {\n      if (!conditions.skus.includes(product.sku)) return false;\n    }\n\n    // SKU pattern filter\n    if (conditions.skuPatterns && conditions.skuPatterns.length > 0) {\n      const matches = conditions.skuPatterns.some((pattern) =>\n        new RegExp(pattern).test(product.sku)\n      );\n      if (!matches) return false;\n    }\n\n    // Margin conditions\n    if (conditions.marginBelow !== undefined) {\n      if (breakdown.marginPercent >= conditions.marginBelow) return false;\n    }\n    if (conditions.marginAbove !== undefined) {\n      if (breakdown.marginPercent <= conditions.marginAbove) return false;\n    }\n\n    // Stock conditions\n    if (conditions.stockBelow !== undefined) {\n      if (product.stockLevel >= conditions.stockBelow) return false;\n    }\n    if (conditions.stockAbove !== undefined) {\n      if (product.stockLevel <= conditions.stockAbove) return false;\n    }\n\n    // Sales velocity conditions\n    if (conditions.salesVelocityBelow !== undefined) {\n      if (product.salesLast7Days >= conditions.salesVelocityBelow) return false;\n    }\n    if (conditions.salesVelocityAbove !== undefined) {\n      if (product.salesLast7Days <= conditions.salesVelocityAbove) return false;\n    }\n\n    // Price conditions\n    if (conditions.priceBelow !== undefined) {\n      if (product.currentPrice >= conditions.priceBelow) return false;\n    }\n    if (conditions.priceAbove !== undefined) {\n      if (product.currentPrice <= conditions.priceAbove) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Apply a rule's action to calculate new price\n   */\n  private applyRule(\n    rule: PricingRule,\n    product: Product,\n    channel: Channel\n  ): { price: number; reason: string } {\n    const action = rule.action;\n\n    switch (action.type) {\n      case 'set_margin': {\n        // Calculate price to achieve target margin\n        const targetMargin = action.value / 100;\n        const totalCostRate =\n          (channel.commissionPercent +\n            (channel.paymentProcessingPercent || 0) +\n            (channel.defaultAcosPercent || 0)) /\n          100;\n        const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n        // Price = FixedCosts / (1 - totalCostRate - targetMargin)\n        const divisor = 1 - totalCostRate - targetMargin;\n        if (divisor <= 0) {\n          return {\n            price: product.currentPrice,\n            reason: `Cannot achieve ${action.value}% margin - costs too high`,\n          };\n        }\n        const price = fixedCosts / divisor;\n        return {\n          price,\n          reason: `Set to achieve ${action.value}% margin (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_markup': {\n        // Price = Cost \u00D7 Markup multiplier\n        const price = (product.costPrice || 0) * action.value;\n        return {\n          price,\n          reason: `Applied ${action.value}x markup on cost (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_percent': {\n        // Adjust by percentage\n        const price = product.currentPrice * (1 + action.value / 100);\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `${Math.abs(action.value)}% ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'adjust_fixed': {\n        // Adjust by fixed amount\n        const price = product.currentPrice + action.value;\n        const direction = action.value >= 0 ? 'increase' : 'decrease';\n        return {\n          price,\n          reason: `\u00A3${Math.abs(action.value).toFixed(2)} ${direction} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'set_price': {\n        return {\n          price: action.value,\n          reason: `Set to fixed price \u00A3${action.value.toFixed(2)} (rule: ${rule.name})`,\n        };\n      }\n\n      case 'match_mrp': {\n        return {\n          price: product.mrp,\n          reason: `Set to MRP (rule: ${rule.name})`,\n        };\n      }\n\n      case 'discount_from_mrp': {\n        const price = product.mrp * (1 - action.value / 100);\n        return {\n          price,\n          reason: `${action.value}% discount from MRP (rule: ${rule.name})`,\n        };\n      }\n\n      default:\n        return {\n          price: product.currentPrice,\n          reason: 'Unknown action type',\n        };\n    }\n  }\n\n  /**\n   * Calculate floor price (minimum to achieve minimum margin)\n   */\n  private calculateFloorPrice(product: Product, channel: Channel): number {\n    const targetMargin = this.config.minimumMarginPercent / 100;\n    const totalCostRate =\n      (channel.commissionPercent +\n        (channel.paymentProcessingPercent || 0) +\n        (channel.defaultAcosPercent || 0)) /\n      100;\n    const fixedCosts = (product.costPrice || 0) + (product.deliveryCost || 0) + (channel.fixedFee || 0);\n\n    const divisor = 1 - totalCostRate - targetMargin;\n    if (divisor <= 0) return product.currentPrice;\n\n    return fixedCosts / divisor;\n  }\n\n  /**\n   * Apply rounding rule to price\n   */\n  private applyRounding(price: number, rule: RoundingRule): number {\n    switch (rule) {\n      case 'nearest_99p':\n        return Math.floor(price) + 0.99;\n      case 'nearest_95p':\n        return Math.floor(price) + 0.95;\n      case 'nearest_pound':\n        return Math.round(price);\n      case 'round_down':\n        return Math.floor(price * 100) / 100;\n      case 'round_up':\n        return Math.ceil(price * 100) / 100;\n      case 'none':\n      default:\n        return Math.round(price * 100) / 100;\n    }\n  }\n\n  /**\n   * Generate proposals for all products\n   */\n  generateProposals(products: Product[], batchId: string): PriceProposal[] {\n    const proposals: PriceProposal[] = [];\n\n    for (const product of products) {\n      const result = this.calculatePrice(product);\n\n      // Only create proposal if price changed\n      if (Math.abs(result.priceChange) < 0.01) continue;\n\n      const proposal: PriceProposal = {\n        proposalId: uuid(),\n        sku: product.sku,\n        productTitle: product.title,\n        brand: product.brand,\n        category: product.category,\n        currentPrice: result.currentPrice,\n        proposedPrice: result.proposedPrice,\n        priceChange: result.priceChange,\n        priceChangePercent: result.priceChangePercent,\n        currentMargin: result.currentMargin,\n        proposedMargin: result.proposedMargin,\n        marginChange: result.marginChange,\n        costBreakdown: result.costBreakdown,\n        stockLevel: product.stockLevel,\n        salesLast7Days: product.salesLast7Days,\n        salesLast30Days: product.salesLast30Days,\n        appliedRuleName: result.appliedRule,\n        reason: result.reason,\n        warnings: result.warnings,\n        status: 'pending',\n        createdAt: new Date().toISOString(),\n        batchId,\n        ttl: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60, // 30 days\n      };\n\n      proposals.push(proposal);\n    }\n\n    return proposals;\n  }\n}\n", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport {\n  DynamoDBDocumentClient,\n  GetCommand,\n  PutCommand,\n  QueryCommand,\n  ScanCommand,\n  UpdateCommand,\n  BatchWriteCommand,\n} from '@aws-sdk/lib-dynamodb';\nimport {\n  Product,\n  Channel,\n  PricingRule,\n  PriceProposal,\n  ProposalStatus,\n  ProposalFilters,\n  PaginatedProposals,\n  Order,\n} from '../types';\n\n/**\n * DynamoDB service for all database operations\n */\nexport class DynamoDBService {\n  private docClient: DynamoDBDocumentClient;\n  private productsTable: string;\n  private rulesTable: string;\n  private proposalsTable: string;\n  private channelsTable: string;\n  private ordersTable: string;\n\n  constructor(config: {\n    productsTable: string;\n    rulesTable: string;\n    proposalsTable: string;\n    channelsTable: string;\n    ordersTable?: string;\n  }) {\n    const client = new DynamoDBClient({});\n    this.docClient = DynamoDBDocumentClient.from(client, {\n      marshallOptions: { removeUndefinedValues: true },\n    });\n\n    this.productsTable = config.productsTable;\n    this.rulesTable = config.rulesTable;\n    this.proposalsTable = config.proposalsTable;\n    this.channelsTable = config.channelsTable;\n    this.ordersTable = config.ordersTable || 'repricing-orders';\n  }\n\n  // ============ Products ============\n\n  async getProduct(sku: string): Promise<Product | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.productsTable,\n        Key: { sku },\n      })\n    );\n    return (result.Item as Product) || null;\n  }\n\n  async putProduct(product: Product): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.productsTable,\n        Item: { ...product, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllProducts(): Promise<Product[]> {\n    const products: Product[] = [];\n    let lastKey: Record<string, unknown> | undefined;\n\n    do {\n      const result = await this.docClient.send(\n        new ScanCommand({\n          TableName: this.productsTable,\n          ExclusiveStartKey: lastKey,\n        })\n      );\n\n      if (result.Items) {\n        products.push(...(result.Items as Product[]));\n      }\n      lastKey = result.LastEvaluatedKey;\n    } while (lastKey);\n\n    return products;\n  }\n\n  async batchPutProducts(products: Product[]): Promise<void> {\n    const timestamp = new Date().toISOString();\n\n    // DynamoDB batch write limit is 25 items\n    const chunks = this.chunkArray(products, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.productsTable]: chunk.map((product) => ({\n              PutRequest: {\n                Item: { ...product, lastUpdated: timestamp },\n              },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProductsByBrand(brand: string): Promise<Product[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.productsTable,\n        IndexName: 'by-brand',\n        KeyConditionExpression: 'brand = :brand',\n        ExpressionAttributeValues: { ':brand': brand },\n      })\n    );\n    return (result.Items as Product[]) || [];\n  }\n\n  // ============ Pricing Rules ============\n\n  async getRule(ruleId: string): Promise<PricingRule | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n    return (result.Item as PricingRule) || null;\n  }\n\n  async putRule(rule: PricingRule): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.rulesTable,\n        Item: { ...rule, updatedAt: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllRules(): Promise<PricingRule[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.rulesTable,\n      })\n    );\n    return ((result.Items as PricingRule[]) || []).sort((a, b) => a.priority - b.priority);\n  }\n\n  async deleteRule(ruleId: string): Promise<void> {\n    const { DeleteCommand } = await import('@aws-sdk/lib-dynamodb');\n    await this.docClient.send(\n      new DeleteCommand({\n        TableName: this.rulesTable,\n        Key: { ruleId },\n      })\n    );\n  }\n\n  // ============ Proposals ============\n\n  async getProposal(proposalId: string): Promise<PriceProposal | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n      })\n    );\n    return (result.Item as PriceProposal) || null;\n  }\n\n  async putProposal(proposal: PriceProposal): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.proposalsTable,\n        Item: proposal,\n      })\n    );\n  }\n\n  async batchPutProposals(proposals: PriceProposal[]): Promise<void> {\n    const chunks = this.chunkArray(proposals, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.proposalsTable]: chunk.map((proposal) => ({\n              PutRequest: { Item: proposal },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getProposalsByStatus(status: ProposalStatus): Promise<PriceProposal[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.proposalsTable,\n        IndexName: 'by-status',\n        KeyConditionExpression: '#status = :status',\n        ExpressionAttributeNames: { '#status': 'status' },\n        ExpressionAttributeValues: { ':status': status },\n        ScanIndexForward: false, // Most recent first\n      })\n    );\n    return (result.Items as PriceProposal[]) || [];\n  }\n\n  async queryProposals(\n    filters: ProposalFilters,\n    page: number = 1,\n    pageSize: number = 50\n  ): Promise<PaginatedProposals> {\n    // Build filter expression\n    const filterExpressions: string[] = [];\n    const expressionAttributeNames: Record<string, string> = {};\n    const expressionAttributeValues: Record<string, unknown> = {};\n\n    if (filters.status) {\n      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];\n      if (statuses.length === 1) {\n        filterExpressions.push('#status = :status');\n        expressionAttributeNames['#status'] = 'status';\n        expressionAttributeValues[':status'] = statuses[0];\n      }\n    }\n\n    if (filters.brand) {\n      filterExpressions.push('brand = :brand');\n      expressionAttributeValues[':brand'] = filters.brand;\n    }\n\n    if (filters.batchId) {\n      filterExpressions.push('batchId = :batchId');\n      expressionAttributeValues[':batchId'] = filters.batchId;\n    }\n\n    if (filters.hasWarnings) {\n      filterExpressions.push('size(warnings) > :zero');\n      expressionAttributeValues[':zero'] = 0;\n    }\n\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.proposalsTable,\n        FilterExpression: filterExpressions.length > 0 ? filterExpressions.join(' AND ') : undefined,\n        ExpressionAttributeNames:\n          Object.keys(expressionAttributeNames).length > 0 ? expressionAttributeNames : undefined,\n        ExpressionAttributeValues:\n          Object.keys(expressionAttributeValues).length > 0 ? expressionAttributeValues : undefined,\n      })\n    );\n\n    let items = (result.Items as PriceProposal[]) || [];\n\n    // Apply search filter (client-side for simplicity)\n    if (filters.searchTerm) {\n      const term = filters.searchTerm.toLowerCase();\n      items = items.filter(\n        (p) =>\n          p.sku.toLowerCase().includes(term) ||\n          p.productTitle.toLowerCase().includes(term)\n      );\n    }\n\n    // Sort by createdAt descending\n    items.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Paginate\n    const totalCount = items.length;\n    const startIndex = (page - 1) * pageSize;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n\n    return {\n      items: paginatedItems,\n      totalCount,\n      page,\n      pageSize,\n      hasMore: startIndex + pageSize < totalCount,\n    };\n  }\n\n  async updateProposalStatus(\n    proposalId: string,\n    status: ProposalStatus,\n    reviewedBy: string,\n    notes?: string,\n    approvedPrice?: number\n  ): Promise<void> {\n    const updateExpressions: string[] = [\n      '#status = :status',\n      'reviewedAt = :reviewedAt',\n      'reviewedBy = :reviewedBy',\n    ];\n    const expressionAttributeNames: Record<string, string> = { '#status': 'status' };\n    const expressionAttributeValues: Record<string, unknown> = {\n      ':status': status,\n      ':reviewedAt': new Date().toISOString(),\n      ':reviewedBy': reviewedBy,\n    };\n\n    if (notes) {\n      updateExpressions.push('reviewNotes = :notes');\n      expressionAttributeValues[':notes'] = notes;\n    }\n\n    if (approvedPrice !== undefined) {\n      updateExpressions.push('approvedPrice = :approvedPrice');\n      expressionAttributeValues[':approvedPrice'] = approvedPrice;\n    }\n\n    await this.docClient.send(\n      new UpdateCommand({\n        TableName: this.proposalsTable,\n        Key: { proposalId },\n        UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n        ExpressionAttributeNames: expressionAttributeNames,\n        ExpressionAttributeValues: expressionAttributeValues,\n      })\n    );\n  }\n\n  // ============ Channels ============\n\n  async getChannel(channelId: string): Promise<Channel | null> {\n    const result = await this.docClient.send(\n      new GetCommand({\n        TableName: this.channelsTable,\n        Key: { channelId },\n      })\n    );\n    return (result.Item as Channel) || null;\n  }\n\n  async putChannel(channel: Channel): Promise<void> {\n    await this.docClient.send(\n      new PutCommand({\n        TableName: this.channelsTable,\n        Item: { ...channel, lastUpdated: new Date().toISOString() },\n      })\n    );\n  }\n\n  async getAllChannels(): Promise<Channel[]> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.channelsTable,\n      })\n    );\n    return (result.Items as Channel[]) || [];\n  }\n\n  // ============ Orders ============\n\n  async batchPutOrders(orders: Order[]): Promise<void> {\n    const chunks = this.chunkArray(orders, 25);\n\n    for (const chunk of chunks) {\n      await this.docClient.send(\n        new BatchWriteCommand({\n          RequestItems: {\n            [this.ordersTable]: chunk.map((order) => ({\n              PutRequest: { Item: order },\n            })),\n          },\n        })\n      );\n    }\n  }\n\n  async getOrdersByDate(dateDay: string): Promise<Order[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.ordersTable,\n        IndexName: 'by-date',\n        KeyConditionExpression: 'orderDateDay = :dateDay',\n        ExpressionAttributeValues: { ':dateDay': dateDay },\n      })\n    );\n    return (result.Items as Order[]) || [];\n  }\n\n  async getOrdersByChannel(\n    channelName: string,\n    fromDate: string,\n    toDate: string\n  ): Promise<Order[]> {\n    const result = await this.docClient.send(\n      new QueryCommand({\n        TableName: this.ordersTable,\n        IndexName: 'by-channel',\n        KeyConditionExpression: 'channelName = :channel AND orderDate BETWEEN :fromDate AND :toDate',\n        ExpressionAttributeValues: {\n          ':channel': channelName,\n          ':fromDate': fromDate,\n          ':toDate': toDate,\n        },\n      })\n    );\n    return (result.Items as Order[]) || [];\n  }\n\n  async getOrderCount(): Promise<number> {\n    const result = await this.docClient.send(\n      new ScanCommand({\n        TableName: this.ordersTable,\n        Select: 'COUNT',\n      })\n    );\n    return result.Count || 0;\n  }\n\n  async getSalesBySku(days: number = 7): Promise<Map<string, { quantity: number; revenue: number }>> {\n    const salesMap = new Map<string, { quantity: number; revenue: number }>();\n\n    // Get orders for each day in the range\n    const today = new Date();\n    const dateDays: string[] = [];\n    for (let i = 0; i < days; i++) {\n      const d = new Date(today);\n      d.setDate(d.getDate() - i);\n      dateDays.push(d.toISOString().substring(0, 10));\n    }\n\n    // Query orders for each day and aggregate\n    for (const dateDay of dateDays) {\n      const orders = await this.getOrdersByDate(dateDay);\n      for (const order of orders) {\n        if (order.lines) {\n          for (const line of order.lines) {\n            const existing = salesMap.get(line.sku) || { quantity: 0, revenue: 0 };\n            existing.quantity += line.quantity;\n            existing.revenue += line.lineTotalInclVat;\n            salesMap.set(line.sku, existing);\n          }\n        }\n      }\n    }\n\n    return salesMap;\n  }\n\n  // ============ Utilities ============\n\n  private chunkArray<T>(array: T[], size: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n}\n\n/**\n * Create DynamoDB service from environment variables\n */\nexport function createDynamoDBService(): DynamoDBService {\n  return new DynamoDBService({\n    productsTable: process.env.PRODUCTS_TABLE || 'repricing-products',\n    rulesTable: process.env.PRICING_RULES_TABLE || 'repricing-rules',\n    proposalsTable: process.env.PRICE_PROPOSALS_TABLE || 'repricing-proposals',\n    channelsTable: process.env.CHANNEL_CONFIG_TABLE || 'repricing-channels',\n    ordersTable: process.env.ORDERS_TABLE || 'repricing-orders',\n  });\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "handler", "__toCommonJS", "import_googleapis", "ChannelEngineService", "config", "endpoint", "method", "body", "queryParams", "params", "key", "value", "url", "response", "errorText", "onBatch", "allProducts", "page", "pageSize", "hasMore", "totalCount", "batchProducts", "product", "error", "fromDate", "toDate", "salesMap", "fromStr", "toStr", "order", "line", "existing", "now", "sevenDaysAgo", "thirtyDaysAgo", "sales7Days", "sales30Days", "allSkus", "sku", "allOrders", "updates", "errors", "i", "chunk", "payload", "u", "createChannelEngineService", "secretArn", "SecretsManagerClient", "GetSecretValueCommand", "secret", "import_uuid", "import_client_dynamodb", "import_lib_dynamodb", "DynamoDBService", "config", "client", "sku", "product", "products", "lastKey", "result", "timestamp", "chunks", "chunk", "brand", "ruleId", "rule", "a", "b", "DeleteCommand", "proposalId", "proposal", "proposals", "status", "filters", "page", "pageSize", "filterExpressions", "expressionAttributeNames", "expressionAttributeValues", "statuses", "items", "term", "totalCount", "startIndex", "reviewedBy", "notes", "approvedPrice", "updateExpressions", "channelId", "channel", "orders", "order", "dateDay", "channelName", "fromDate", "toDate", "days", "salesMap", "today", "dateDays", "i", "d", "line", "existing", "array", "size", "createDynamoDBService", "handler", "event", "context", "db", "createDynamoDBService", "totalSaved", "totalProducts", "existingProducts", "existingMap", "p", "secretArn", "createChannelEngineService", "batchProducts", "page", "total", "timestamp", "productsToSave", "ceProduct", "sku", "existing", "error"]
}
